//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlInvokeAsync
    {
        /// <summary>
        /// MLInvokeParams represents a user defined type
        /// A user-supplied blocking method accepts a pointer to this type as its single argument
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly struct MLInvokeParams : IEquatable<MLInvokeParams>
        {
            private readonly IntPtr _handle;

            public MLInvokeParams(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(MLInvokeParams other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is MLInvokeParams other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(MLInvokeParams left, MLInvokeParams right) => left.Equals(right);

            public static bool operator !=(MLInvokeParams left, MLInvokeParams right) => !left.Equals(right);
        }

        /// <summary>
        /// MLInvokeResult represents a user defined type
        /// A user-supplied blocking method returns a pointer to this type
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly struct MLInvokeResult : IEquatable<MLInvokeResult>
        {
            private readonly IntPtr _handle;

            public MLInvokeResult(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(MLInvokeResult other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is MLInvokeResult other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(MLInvokeResult left, MLInvokeResult right) => left.Equals(right);

            public static bool operator !=(MLInvokeResult left, MLInvokeResult right) => !left.Equals(right);
        }

        /// <summary>
        /// MLInvokerContext represents a user defined type
        /// A pointer to this type is supplied by the user to the AsyncWithCallback method and is then
        /// passed to the user-supplied callback method when the asynchronous operation completes
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly struct MLInvokerContext : IEquatable<MLInvokerContext>
        {
            private readonly IntPtr _handle;

            public MLInvokerContext(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(MLInvokerContext other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is MLInvokerContext other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(MLInvokerContext left, MLInvokerContext right) => left.Equals(right);

            public static bool operator !=(MLInvokerContext left, MLInvokerContext right) => !left.Equals(right);
        }

        /// <summary>
        /// MLInvokeFuture represents a type which is opaque (incomplete) to users of this library
        /// A pointer to an MLInvokeFuture is returned by the Async function
        /// Users pass it to the Wait function to determine if the asynchronous method has
        /// completed and to retrieve the result if it has
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly struct MLInvokeFuture : IEquatable<MLInvokeFuture>
        {
            private readonly IntPtr _handle;

            public MLInvokeFuture(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(MLInvokeFuture other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is MLInvokeFuture other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(MLInvokeFuture left, MLInvokeFuture right) => left.Equals(right);

            public static bool operator !=(MLInvokeFuture left, MLInvokeFuture right) => !left.Equals(right);
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate MlInvokeAsync.MLInvokeResult MLInvokeMethod(MlInvokeAsync.MLInvokeParams arg0);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void MLCallbackMethod(MlInvokeAsync.MLInvokerContext arg0, MlInvokeAsync.MLInvokeResult arg1);
    }
}

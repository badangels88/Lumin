//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlMeshing2
    {
        /// <summary>
        /// Request flags for the meshing system
        /// </summary>
        [Flags]
        public enum MLMeshingFlags : int
        {
            /// <summary>
            /// If set, will return a point cloud instead of a triangle mesh
            /// </summary>
            MLMeshingFlags_PointCloud = unchecked((int)1 << (int) 0),

            /// <summary>
            /// If set, the system will compute the normals for the triangle vertices
            /// </summary>
            MLMeshingFlags_ComputeNormals = unchecked((int)1 << (int) 1),

            /// <summary>
            /// If set, the system will compute the confidence values
            /// </summary>
            MLMeshingFlags_ComputeConfidence = unchecked((int)1 << (int) 2),

            /// <summary>
            /// If set, the system will planarize the returned mesh (planar regions will be smoothed out)
            /// </summary>
            MLMeshingFlags_Planarize = unchecked((int)1 << (int) 3),

            /// <summary>
            /// If set, the mesh skirt (overlapping area between two mesh blocks) will be removed
            /// </summary>
            MLMeshingFlags_RemoveMeshSkirt = unchecked((int)1 << (int) 4),

            /// <summary>
            /// If set, winding order of indices will be be changed from clockwise to counter clockwise
            /// This could be useful for face culling process in different engines
            /// </summary>
            MLMeshingFlags_IndexOrderCCW = unchecked((int)1 << (int) 5),

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMeshingFlags_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Level of detail of the block mesh
        /// </summary>
        public enum MLMeshingLOD : int
        {
            /// <summary>
            /// Minimum Level of Detail (LOD) for the mesh
            /// </summary>
            MLMeshingLOD_Minimum,

            /// <summary>
            /// Medium Level of Detail (LOD) for the mesh
            /// </summary>
            MLMeshingLOD_Medium,

            /// <summary>
            /// Maximum Level of Detail (LOD) for the mesh
            /// </summary>
            MLMeshingLOD_Maximum,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMeshingLOD_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Result of a mesh request
        /// </summary>
        public enum MLMeshingResult : int
        {
            /// <summary>
            /// Mesh request has succeeded
            /// </summary>
            MLMeshingResult_Success,

            /// <summary>
            /// Mesh request has failed
            /// </summary>
            MLMeshingResult_Failed,

            /// <summary>
            /// Mesh request is pending
            /// </summary>
            MLMeshingResult_Pending,

            /// <summary>
            /// There are partial updates on the mesh request
            /// </summary>
            MLMeshingResult_PartialUpdate,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMeshingResult_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// State of a block mesh
        /// </summary>
        public enum MLMeshingMeshState : int
        {
            /// <summary>
            /// Mesh has been created
            /// </summary>
            MLMeshingMeshState_New,

            /// <summary>
            /// Mesh has been updated
            /// </summary>
            MLMeshingMeshState_Updated,

            /// <summary>
            /// Mesh has been deleted
            /// </summary>
            MLMeshingMeshState_Deleted,

            /// <summary>
            /// Mesh is unchanged
            /// </summary>
            MLMeshingMeshState_Unchanged,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMeshingMeshState_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Mesh Settings for the underlying system
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMeshingSettings
        {
            /// <summary>
            /// Request flags that are a combination of MLMeshingFlags
            /// </summary>
            public uint flags;

            /// <summary>
            /// Perimeter (in meters) of holes you wish to have filled
            /// </summary>
            public float fill_hole_length;

            /// <summary>
            /// Any component that is disconnected from the main mesh and
            /// which has an area (in meters^2) less than this size will be removed
            /// </summary>
            public float disconnected_component_area;
        }

        /// <summary>
        /// Axis aligned bounding box for querying updated mesh info
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMeshingExtents
        {
            /// <summary>
            /// The center of the bounding box
            /// </summary>
            public MlTypes.MLVec3f center;

            /// <summary>
            /// The rotation of the bounding box
            /// </summary>
            public MlTypes.MLQuaternionf rotation;

            /// <summary>
            /// The size of the bounding box
            /// </summary>
            public MlTypes.MLVec3f extents;
        }

        /// <summary>
        /// Representation of a mesh block
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMeshingBlockInfo
        {
            /// <summary>
            /// The coordinate frame UID to represent the block
            /// </summary>
            public MlCoordinateFrameUid.MLCoordinateFrameUID id;

            /// <summary>
            /// The extents of the bounding box
            /// </summary>
            public MlMeshing2.MLMeshingExtents extents;

            /// <summary>
            /// The timestamp when block was updated
            /// </summary>
            public ulong timestamp;

            /// <summary>
            /// The state of the Mesh Block
            /// </summary>
            public MlMeshing2.MLMeshingMeshState state;
        }

        /// <summary>
        /// Response structure for the mesh block info
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMeshingMeshInfo
        {
            /// <summary>
            /// The response timestamp to a earlier request
            /// </summary>
            public ulong timestamp;

            /// <summary>
            /// The number of responses in data pointer
            /// </summary>
            public uint data_count;

            /// <summary>
            /// The meshinfo returned by the system
            /// </summary>
            public IntPtr data;
        }

        /// <summary>
        /// Request structure to get the actual mesh for a block
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMeshingBlockRequest
        {
            /// <summary>
            /// The UID to represent the block
            /// </summary>
            public MlCoordinateFrameUid.MLCoordinateFrameUID id;

            /// <summary>
            /// The LOD level to request
            /// </summary>
            public MlMeshing2.MLMeshingLOD level;
        }

        /// <summary>
        /// Request structure to get the actual mesh for a set of blocks
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMeshingMeshRequest
        {
            /// <summary>
            /// The number of blocks requested
            /// </summary>
            public int request_count;

            /// <summary>
            /// Per block request
            /// </summary>
            public IntPtr data;
        }

        /// <summary>
        /// Final structure for a block mesh
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMeshingBlockMesh
        {
            /// <summary>
            /// The result of the meshing
            /// </summary>
            public MlMeshing2.MLMeshingResult result;

            /// <summary>
            /// The coordinate FrameID of the block
            /// </summary>
            public MlCoordinateFrameUid.MLCoordinateFrameUID id;

            /// <summary>
            /// The LOD level of the meshing request
            /// </summary>
            public MlMeshing2.MLMeshingLOD level;

            /// <summary>
            /// The settings with which meshing took place
            /// </summary>
            public uint flags;

            /// <summary>
            /// The number of indices in index buffer
            /// </summary>
            public ushort index_count;

            /// <summary>
            /// The number of vertices in vertex/normal/confidence buffer
            /// </summary>
            public uint vertex_count;

            /// <summary>
            /// Pointer to the vertex buffer
            /// </summary>
            public IntPtr vertex;

            /// <summary>
            /// Pointer to index buffer In the index buffer each value
            /// is the index of a vertex in the vertex buffer Three indices
            /// define one triangle For example, the first triangle will have
            /// the vertices: vertex[index[0]], vertex[index[1]], vertex[index[2]]
            /// Index order is defined by the MLMeshingFlags_IndexOrderCCW flag
            /// </summary>
            public IntPtr index;

            /// <summary>
            /// Pointer to normals buffer
            /// </summary>
            public IntPtr normal;

            /// <summary>
            /// Pointer to confidence buffer
            /// </summary>
            public IntPtr confidence;
        }

        /// <summary>
        /// Result of a Mesh request See MLMeshingGetMeshResult
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMeshingMesh
        {
            /// <summary>
            /// The result of the meshing Can have partial updates
            /// </summary>
            public MlMeshing2.MLMeshingResult result;

            /// <summary>
            /// The timestamp when data was generated
            /// </summary>
            public ulong timestamp;

            /// <summary>
            /// Number of meshes available in data
            /// </summary>
            public uint data_count;

            /// <summary>
            /// The mesh data
            /// </summary>
            public IntPtr data;
        }

        /// <summary>
        /// Create the meshing client
        /// </summary>
        /// <param name="out_client_handle">The handle to the created client</param>
        /// <param name="settings">The initial settings to be used for meshing</param>
        /// <returns>
        /// MLResult_InvalidParam Meshing Client was not created due to an invalid parameter
        /// MLResult_Ok Meshing Client was created successfully
        /// MLResult_PrivilegeDenied Client was not created due to insufficient privilege
        /// MLResult_UnspecifiedFailure Meshing Client was not created due to an unknown error
        /// </returns>
        /// <remarks>
        /// Note that this will be the only function in the meshing API that will return MLResult_PrivilegeDenied
        /// Trying to call the other functions with an invalid MLHandle will result in MLResult_InvalidParam
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingCreateClient(ref MlApi.MLHandle out_client_handle, in MlMeshing2.MLMeshingSettings settings);

        /// <summary>
        /// Free the client resources
        /// </summary>
        /// <param name="client_handle">The client to destroy</param>
        /// <returns>
        /// MLResult_InvalidParam Meshing Client was not destroyed due to an invalid parameter
        /// MLResult_Ok Meshing Client was destroyed successfully
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingDestroyClient(ref MlApi.MLHandle client_handle);

        /// <summary>
        /// Initialize the meshing settings with system defaults
        /// </summary>
        /// <param name="out_settings">The initial settings to be used for meshing</param>
        /// <returns>
        /// MLResult_InvalidParam Mesh Settings were not initialized due to an invalid parameter
        /// MLResult_Ok Mesh Settings were initialized successfully
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingInitSettings(ref MlMeshing2.MLMeshingSettings out_settings);

        /// <summary>
        /// Update the meshing settings at runtime
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="settings">The updated settings to be used for meshing</param>
        /// <returns>
        /// MLResult_InvalidParam Mesh Settings were not updated due to an invalid parameter
        /// MLResult_Ok Mesh Settings were updated successfully
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingUpdateSettings(MlApi.MLHandle client_handle, in MlMeshing2.MLMeshingSettings settings);

        /// <summary>
        /// Request the Mesh Info which includes CFUIDs and bounding extents of the blocks
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="extents">The region of interest for meshing</param>
        /// <param name="out_request_handle">The handle for the current request Needs to be passed to query the result of the request</param>
        /// <returns>
        /// MLResult_InvalidParam Mesh info was not requested due to an invalid parameter
        /// MLResult_Ok Mesh Info was requested successfully
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingRequestMeshInfo(MlApi.MLHandle client_handle, in MlMeshing2.MLMeshingExtents extents, ref MlApi.MLHandle out_request_handle);

        /// <summary>
        /// Get the Result of a previous MeshInfo request
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="request_handle">The handle populated in a prev MLMeshingGetMeshInfo</param>
        /// <param name="out_info">The final result which will be populated only if the result is successful</param>
        /// <returns>
        /// MLResult_InvalidParam Mesh Settings were not updated due to an invalid parameter
        /// MLResult_Ok Mesh Info was populated successfully
        /// MLResult_Peding Mesh Info is pending update
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingGetMeshInfoResult(MlApi.MLHandle client_handle, MlApi.MLHandle request_handle, ref MlMeshing2.MLMeshingMeshInfo out_info);

        /// <summary>
        /// Request the Mesh for all CFUIDs populated in request
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="request">The request for meshes of interest</param>
        /// <param name="out_request_handle">The handle for the current request Needs to be passed to query the result of the request</param>
        /// <returns>
        /// MLResult_InvalidParam Meshes were not requested due to an invalid parameter
        /// MLResult_Ok Meshes were requested successfully
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingRequestMesh(MlApi.MLHandle client_handle, in MlMeshing2.MLMeshingMeshRequest request, ref MlApi.MLHandle out_request_handle);

        /// <summary>
        /// Get the Result of a previous Mesh request
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="request_handle">The handle populated in a prev MLMeshingGetMesh</param>
        /// <param name="out_mesh">The final result which will be populated only if the result is successful</param>
        /// <returns>
        /// MLResult_InvalidParam Meshes were not updated due to an invalid parameter
        /// MLResult_Ok Meshes was populated successfully
        /// MLResult_Peding Meshes pending update
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingGetMeshResult(MlApi.MLHandle client_handle, MlApi.MLHandle request_handle, ref MlMeshing2.MLMeshingMesh out_mesh);

        /// <summary>
        /// Free resources created by the meshing APIS Needs to be called whenever MLMeshingGetMeshInfoResult,
        /// MLMeshingGetMeshResult return a success
        /// </summary>
        /// <param name="client_handle">The handle to the created client</param>
        /// <param name="request_handle">The handle populated in a prev request</param>
        /// <returns>
        /// MLResult_InvalidParam Resources were not freed due to an invalid parameter
        /// MLResult_Ok Resources were freed successfully
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMeshingFreeResource(MlApi.MLHandle client_handle, ref MlApi.MLHandle request_handle);
    }
}

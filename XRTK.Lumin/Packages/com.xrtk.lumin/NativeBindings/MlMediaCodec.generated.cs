//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlMediaCodec
    {
        /// <summary>
        /// Media codec creation method
        /// </summary>
        public enum MLMediaCodecCreation : int
        {
            /// <summary>
            /// Create by name
            /// </summary>
            MLMediaCodecCreation_ByName,

            /// <summary>
            /// Create by type
            /// </summary>
            MLMediaCodecCreation_ByType,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMediaCodecCreation_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Media codec type
        /// </summary>
        public enum MLMediaCodecType : int
        {
            /// <summary>
            /// Encoder
            /// </summary>
            MLMediaCodecType_Encoder,

            /// <summary>
            /// Decoder
            /// </summary>
            MLMediaCodecType_Decoder,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMediaCodecType_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Media codec surface hint
        /// </summary>
        public enum MLMediaCodecSurfaceHint : int
        {
            /// <summary>
            /// Hardware
            /// </summary>
            MLMediaCodecSurfaceHint_Hardware,

            /// <summary>
            /// Software
            /// </summary>
            MLMediaCodecSurfaceHint_Software,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMediaCodecSurfaceHint_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Indicate the type of data when queuing the input buffer via
        /// MLMediaCodecQueueInputBuffer or MLMediaCodecQueueSecureInputBuffer
        /// </summary>
        public enum MLMediaCodecBufferFlag : int
        {
            MLMediaCodecBufferFlag_KeyFrame = unchecked((int)1),

            MLMediaCodecBufferFlag_CodecConfig = unchecked((int)2),

            MLMediaCodecBufferFlag_EOS = unchecked((int)4),

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMediaCodecBufferFlag_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Other than the normal buffer index, the output of MLMediaCodecDequeueOutputBuffer
        /// can take on one of these statuses
        /// </summary>
        public enum MLMediaCodecOutputBufferStatus : int
        {
            /// <summary>
            /// Output buffer changed
            /// </summary>
            MLMediaCodec_OutputBuffersChanged = unchecked((int)-1014),

            /// <summary>
            /// Format changed
            /// </summary>
            MLMediaCodec_FormatChanged = unchecked((int)-1012),

            /// <summary>
            /// Try again later
            /// </summary>
            MLMediaCodec_TryAgainLater = unchecked((int)-11),

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLMediaCodecOutputBufferStatus_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Media codec buffer info
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMediaCodecBufferInfo
        {
            /// <summary>
            /// Offset
            /// </summary>
            public Interop.size_t offset;

            /// <summary>
            /// Size
            /// </summary>
            public Interop.size_t size;

            /// <summary>
            /// Flags
            /// </summary>
            public Interop.size_t flags;

            /// <summary>
            /// Presentation time in us
            /// </summary>
            public long presentation_time_us;
        }

        /// <summary>
        /// Callbacks for notifying client about codec events If not using the SYNC API
        /// calls hereunder, client is expected to implement these callbacks and take
        /// proper actions where appropriate
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLMediaCodecCallbacks
        {
            public MlMediaCodec.MLMediaCodecCallbacks.on_input_buffer_available_delegate on_input_buffer_available;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_input_buffer_available_delegate(MlApi.MLHandle media_codec, long input_buffer_index, IntPtr data);

            public MlMediaCodec.MLMediaCodecCallbacks.on_output_buffer_available_delegate on_output_buffer_available;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_output_buffer_available_delegate(MlApi.MLHandle media_codec, long output_buffer_index, ref MlMediaCodec.MLMediaCodecBufferInfo buffer_info, IntPtr data);

            public MlMediaCodec.MLMediaCodecCallbacks.on_output_format_changed_delegate on_output_format_changed;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_output_format_changed_delegate(MlApi.MLHandle media_codec, MlApi.MLHandle new_output_format, IntPtr data);

            public MlMediaCodec.MLMediaCodecCallbacks.on_error_delegate on_error;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_error_delegate(MlApi.MLHandle media_codec, int error_code, IntPtr data);

            public MlMediaCodec.MLMediaCodecCallbacks.on_frame_rendered_delegate on_frame_rendered;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_frame_rendered_delegate(MlApi.MLHandle media_codec, long presentation_time_us, long system_time_nano, IntPtr data);

            public MlMediaCodec.MLMediaCodecCallbacks.on_frame_available_delegate on_frame_available;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_frame_available_delegate(MlApi.MLHandle media_codec, IntPtr data);
        }

        /// <summary>
        /// Create a new
        ///  MediaCodec
        ///  MediaCodecList for retrieving the list of names
        ///  MediaCodec
        ///  MediaCodec object was created successfully
        /// </summary>
        /// <param name="method">One of the creation methods defined by MLMediaCodecCreation</param>
        /// <param name="type">One of the codec types defined by MLMediaCodecType</param>
        /// <param name="name_str">If creating a codec by name, this is the name of the codec
        /// If creating a codec by type, this is the mime type of the codec
        /// Refer to APIs in</param>
        /// <param name="out_handle">Upon successful return will point to handle to the created</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok
        /// </returns>
        /// <returns>
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// and mime types of supported codecs
        /// Or else, it will point to ML_INVALID_HANDLE
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecCreateCodec(MlMediaCodec.MLMediaCodecCreation method, MlMediaCodec.MLMediaCodecType type, [MarshalAs(UnmanagedType.LPStr)] string name_str, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Destroy a
        ///  MediaCodec
        ///  MediaCodec
        ///  MediaCodec object is invalid
        ///  MediaCodec object was successfully destroyed
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <returns>
        /// MLResult_InvalidParam
        /// </returns>
        /// <returns>
        /// MLResult_Ok
        /// </returns>
        /// <returns>
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecDestroy(MlApi.MLHandle handle);

        /// <summary>
        /// Set callbacks to notify client codec events Client needs to implement the callback functions
        ///  MediaCodec
        ///  MediaCodec object is invalid
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="callbacks">Set of codec callbacks Can be set to NULL to unset all the callback altogether</param>
        /// <param name="user_data">Pointer to user payload data</param>
        /// <returns>
        /// MLResult_InvalidParam
        /// </returns>
        /// <returns>
        /// MLResult_Ok callback was set successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecSetCallbacks(MlApi.MLHandle handle, ref MlMediaCodec.MLMediaCodecCallbacks callbacks, IntPtr user_data);

        /// <summary>
        /// Obtain the name of the created codec
        ///  MediaCodec
        ///  MediaCodec name was retrieved successfully
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_name">Pointer to the user-maintained buffer for storing
        /// the output C-style name string</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok
        /// </returns>
        /// <returns>
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// User shall allocate at least MAX_CODEC_NAME_SIZE bytes of memory for
        /// storing the output name string
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetName(MlApi.MLHandle handle, IntPtr out_name);

        /// <summary>
        /// Set surface hint on decoder
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="surface_hint">Hint about intended usage of the decoded buffers @c See notes in description
        /// above for important details about this parameter</param>
        /// <returns>
        /// MLResult_Ok Surface hint was correctly set Note: If called after MLMediaCodecConfigure,
        /// the call will be a NOOP and behavior will default to MLMediaCodecSurfaceHint_Hardware at
        /// configuration time
        /// </returns>
        /// <remarks>
        /// Note that MLMediaCodecSetSurfaceHint *has* to be called before MLMediaCodecConfigure
        /// or else, behavior will default to MLMediaCodecSurfaceHint_Hardware
        /// If surface_hint is set to 'MLMediaCodecSurfaceHint_Hardware', codec will try to create
        /// an internal native hardware surface onto which frames will be directly decoded (zero-copy
        /// fast path) In that case, calls to MLMediaCodecGetOutputBufferPointer will return NULL for
        /// out_buffer_ptr and 0 for out_buffer_size, since decoded buffers will be residing in GPU memory
        /// (note: Only true if codec was correctly configured with an available Hardware decoder on
        /// the system, otherwise, decoder will be software and MLMediaCodecGetOutputBufferPointer will
        /// return CPU-allocated buffer pointer and size) When using MLMediaCodecSurfaceHint_Hardware with
        /// any Hardware Decoder, dequeued output buffers need to be "rendered" onto the internal native surface
        /// by setting 'render' = true when calling MLMediaCodecReleaseOutputBuffer and then, rendered frame
        /// can be retrieved in the form of a native buffer handle by calling MLMediaCodecAcquireNextAvailableFrame
        /// This handle points to an android native buffer and can for example be bound as an external texture
        /// with OpenGLES
        /// If surface_hint is set to MLMediaCodecSurfaceHint_Software, Codec will allocate an internal
        /// buffer on CPU memory onto which decoded buffers will be copied (slow path) In that case,
        /// note that there is no need to "render" the output buffer when releasing it To access
        /// decoded pixels, call MLMediaCodecGetOutputBufferPointer on the buffer handle and
        /// out_buffer_ptr and out_buffer_size will return the correct pointer to data and frame size
        /// Note this mode of operation is very slow and is generally intended for callers with no access
        /// to a compliant graphics library or with very specific needs
        /// Note: This API is only relevant if current codec is VIDEO For AUDIO codec, this call will
        /// just be ignored
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecSetSurfaceHint(MlApi.MLHandle handle, MlMediaCodec.MLMediaCodecSurfaceHint surface_hint);

        /// <summary>
        /// Configure the
        ///  MediaCodec
        ///  MediaCodec
        ///  MediaCodec was configured successfully
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="format_handle">MLHandle to the MediaFormat object</param>
        /// <param name="crypto_handle">MLHandle to the MediaCrypto object
        /// Pass 0 for clear content</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok
        /// </returns>
        /// <returns>
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// MLMediaGenericResult_NoInit Internal native surface could not be allocated by graphics
        /// hardware (only for surface_hint = MLMediaCodecSurfaceHint_Hardware With
        /// MLMediaCodecSurfaceHint_Hardware surface_hint, this return value can't occur)
        /// NOTE: In the surface_hint=MLMediaCodecSurfaceHint_Hardware case, always make sure caller
        /// has created a valid graphics context *before* calling MLMediaCodecConfigure !
        /// The MLMediaGenericResult_NoInit error is not recoverable and caller has to clean codec
        /// object and start anew with different configuration
        /// </returns>
        /// <remarks>
        /// Note that caller should consider calling MLMediaCodecSetSurfaceHint prior to configuring the
        /// codec, as this hint may have important incidence on buffer usage once decoded See documentation
        /// for MLMediaCodecSetSurfaceHint above
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecConfigure(MlApi.MLHandle handle, MlApi.MLHandle format_handle, MlApi.MLHandle crypto_handle);

        /// <summary>
        /// Configure the MediaCodec with a MediaSurfaceTexture
        ///  MediaCodec
        ///  MediaCodec was configured successfully
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="format_handle">MLHandle to the MediaFormat object</param>
        /// <param name="surface_handle">MLHandle to the MediaSurfaceTexture object</param>
        /// <param name="crypto_handle">MLHandle to the MediaCrypto object
        /// Pass 0 for clear content</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok
        /// </returns>
        /// <returns>
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// Same as MLMediaCodecConfigure, but allow passing a custom surface texture created by
        /// MLMediaSurfaceTextureCreate The value set by MLMediaCodecSetSurfaceHint is ignored
        /// @apilevel 6
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecConfigureWithSurface(MlApi.MLHandle handle, MlApi.MLHandle format_handle, MlApi.MLHandle surface_handle, MlApi.MLHandle crypto_handle);

        /// <summary>
        /// Start the codec
        ///  MediaCodec
        ///  MediaCodec object is invalid
        ///  MediaCodec was started successfully
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <returns>
        /// MLResult_InvalidParam
        /// </returns>
        /// <returns>
        /// MLResult_Ok
        /// </returns>
        /// <returns>
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// Shall be called upon successful configuration
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecStart(MlApi.MLHandle handle);

        /// <summary>
        /// Stop the codec
        ///  MediaCodec
        ///  MediaCodec object is invalid
        ///  MediaCodec was stopped successfully
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <returns>
        /// MLResult_InvalidParam
        /// </returns>
        /// <returns>
        /// MLResult_Ok
        /// </returns>
        /// <returns>
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// Codec is stopped and not destroyed, therefore can be started again
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecStop(MlApi.MLHandle handle);

        /// <summary>
        /// Flush the both the input and output ports of the codec
        ///  MediaCodec
        ///  MediaCodec object is invalid
        ///  MediaCodec was flushed successfully
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <returns>
        /// MLResult_InvalidParam
        /// </returns>
        /// <returns>
        /// MLResult_Ok
        /// </returns>
        /// <returns>
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// Upon return, all indices previously returned in calls to
        /// MLMediaCodecDequeueInputBuffer and MLMediaCodecDequeueOutputBuffer
        /// become invalid, and all buffers are owned by the codec
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecFlush(MlApi.MLHandle handle);

        /// <summary>
        /// Obtain a writable buffer pointer for a dequeued
        /// input buffer index to contain the input data
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="buffer_handle">The index of a client-owned input buffer
        /// previously returned from a call to
        /// MLMediaCodecDequeueInputBuffer</param>
        /// <param name="out_buffer_ptr">Pointer to returned input buffer</param>
        /// <param name="out_buffer_size">Size of returned input buffer</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Input buffer pointer is retrieved successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// After calling this method any buffer pointer previously
        /// returned for the same input index MUST no longer be used
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetInputBufferPointer(MlApi.MLHandle handle, MlApi.MLHandle buffer_handle, out IntPtr out_buffer_ptr, ref Interop.size_t out_buffer_size);

        /// <summary>
        /// Obtain a read-only buffer pointer for a dequeued output
        /// buffer index
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="buffer_handle">The index of a client-owned output buffer
        /// previously returned from a call to
        /// MLMediaCodecDequeueOutputBuffer</param>
        /// <param name="out_buffer_ptr">Pointer to returned output buffer</param>
        /// <param name="out_buffer_size">Size of returned output buffer</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Output buffer pointer is retrieved successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// MLMediaGenericResult_InvalidOperation Buffer pointer could not be retrieved Note that this API
        /// returns MLMediaGenericResult_InvalidOperation especially if codec was VIDEO and configured
        /// with a hardware surface (see MLMediaCodecSetSurfaceHint documentation), and thus, out_buffer_ptr
        /// will be set to NULL and out_buffer_size set to 0 since decoded buffer lives in GPU memory and is
        /// not accessible via a pointer
        /// </returns>
        /// <remarks>
        /// The position and limit of the returned buffer are set to the valid output data
        /// After calling this method any buffer pointer previously returned for the same output
        /// index MUST no longer be used
        /// Note: For VIDEO codecs, this API will fail if codec was configured with a hardware surface
        /// (see return value documentation below)
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetOutputBufferPointer(MlApi.MLHandle handle, MlApi.MLHandle buffer_handle, out IntPtr out_buffer_ptr, ref Interop.size_t out_buffer_size);

        /// <summary>
        /// After filling a range of the input buffer at the specified index
        /// submit it to the component
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="buffer_handle">Index of a client-owned input buffer previously returned
        /// in a call to MLMediaCodecDequeueInputBuffer</param>
        /// <param name="offset">Byte offset into the input buffer at which the data starts</param>
        /// <param name="size">Number of bytes of valid input data</param>
        /// <param name="time_us">Presentation timestamp in microseconds for this buffer
        /// This is normally the media time at which this buffer should
        /// be presented (rendered)</param>
        /// <param name="flags">A bitmask of flags defined by MLMediaCodecBufferFlag
        /// While not prohibited, most codecs do not use the
        /// MLMediaCodecBufferFlag_KeyFrame flag for input buffers</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Intput buffer is queued successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// Once an input buffer is queued to the codec, it MUST NOT be used until it is later retrieved by
        /// MLMediaCodecGetInputBuffer in response to a MLMediaCodecDequeueInputBuffer return value
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecQueueInputBuffer(MlApi.MLHandle handle, MlApi.MLHandle buffer_handle, long offset, Interop.size_t size, ulong time_us, int flags);

        /// <summary>
        /// Similar to queueInputBuffer but submits a buffer that is potentially encrypted
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="buffer_handle">Index of a client-owned input buffer previously returned
        /// in a call to MLMediaCodecDequeueInputBuffer</param>
        /// <param name="offset">Byte offset into the input buffer at which the data starts</param>
        /// <param name="crypto_info_handle">Metadata required to facilitate decryption,
        /// the object can be reused immediately after this call returns</param>
        /// <param name="time_us">Presentation timestamp in microseconds for this
        /// buffer This is normally the media time at which this
        /// buffer should be presented (rendered)</param>
        /// <param name="flags">A bitmask of flags defined by MLMediaCodecBufferFlag
        /// While not prohibited, most codecs do not use the
        /// MLMediaCodecBufferFlag_KeyFrame flag for input buffers</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Secure Intput buffer is queued successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecQueueSecureInputBuffer(MlApi.MLHandle handle, MlApi.MLHandle buffer_handle, long offset, MlApi.MLHandle crypto_info_handle, ulong time_us, int flags);

        /// <summary>
        /// Dequeue an input buffer from buffer queue
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="timeout_us">Timeout in microseconds
        /// Negative timeout indicates "infinite"</param>
        /// <param name="out_buffer_handle">Index of an Input buffer from buffer queue,
        /// or MLMediaCodec_TryAgainLater status</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Intput buffer is dequeued successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// This method will return immediately if timeoutUs == 0, wait indefinitely
        /// for the availability of an input buffer if timeoutUs 
        /// &lt;
        /// 0 or wait up
        /// to "timeoutUs" microseconds if timeoutUs &gt; 0
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecDequeueInputBuffer(MlApi.MLHandle handle, long timeout_us, ref long out_buffer_handle);

        /// <summary>
        /// Dequeue an output buffer from buffer queue
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_buffer_info">Will be filled with buffer meta data</param>
        /// <param name="timeout_us">Timeout in microseconds
        /// Negative timeout indicates "infinite"</param>
        /// <param name="out_buffer_handle">Index of an output buffer from buffer queue,
        /// or one of the statuses defined by MLMediaCodecOutputBufferStatus</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Output buffer is dequeued successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// This method will return immediately if timeoutUs == 0, wait indefinitely
        /// for the availability of an input buffer if timeoutUs 
        /// &lt;
        /// 0 or wait up
        /// to "timeoutUs" microseconds if timeoutUs &gt; 0
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecDequeueOutputBuffer(MlApi.MLHandle handle, ref MlMediaCodec.MLMediaCodecBufferInfo out_buffer_info, long timeout_us, ref long out_buffer_handle);

        /// <summary>
        /// Obtain input format supported by the codec
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_format_handle">Input format supported by the codec</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Input Media format is retrieved successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// Call this function, after successful codec configuration, to determine
        /// what optional configuration parameters were supported by the codec
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetInputFormat(MlApi.MLHandle handle, ref MlApi.MLHandle out_format_handle);

        /// <summary>
        /// Return output format supported by the codec, or the format to which the configuration has changed
        ///  MediaCodec
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_format_handle">Output format supported by the codec,
        /// or the format to which the configuration has changed</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Output Media format is retrieved successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetOutputFormat(MlApi.MLHandle handle, ref MlApi.MLHandle out_format_handle);

        /// <summary>
        /// Release buffer to codec or to render it on output surface
        ///  MediaCodec object
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="buffer_handle">Index of a client-owned output buffer previously returned
        /// from a call to MLMediaCodecDequeueOutputBuffer</param>
        /// <param name="render">If a valid surface was specified when configuring the
        /// codec, passing @c true renders this output buffer to the surface</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Output buffer was released successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// If codec is configured with an output surface, setting render
        /// to @c true will send the buffer to that output surface The surface
        /// will release the buffer back to the codec once it is no longer
        /// used/displayed
        /// Once an output buffer is released to codec, it MUST NOT
        /// be used until it is later retrieved by MLMediaCodecGetOutputBuffer
        /// in response to a MLMediaCodecDequeueOutputBuffer return value
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecReleaseOutputBuffer(MlApi.MLHandle handle, MlApi.MLHandle buffer_handle, [MarshalAs(UnmanagedType.U1)] bool render);

        /// <summary>
        /// Update surface timestamp and returns it to the codec to render
        /// it on the output surface If codec is not configured with output
        /// surface, this call simply returns the buffer to codec
        ///  MediaCodec object
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="buffer_handle">Index of a client-owned output buffer previously returned
        /// from a call to MLMediaCodecDequeueOutputBuffer</param>
        /// <param name="timestamp_ns">The timestamp in nanoseconds to associate with this buffer when
        /// it is sent to the Surface</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Output buffer was released successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// The timestamp may have special meaning depending on the destination
        /// surface
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecReleaseOutputBufferAtTime(MlApi.MLHandle handle, MlApi.MLHandle buffer_handle, long timestamp_ns);

        /// <summary>
        /// Consume next available buffer
        ///  MediaCodec instance
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_native_buffer">A pointer to the acquired native buffer of the frame
        /// When buffer is not required anymore, caller must call
        /// MLMediaCodecReleaseFrame with this nativeBuffer handle to free up
        /// queuing space for incoming buffers</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Next available frame is acquired successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// Note: This function is non-blocking and should only be called from the rendering
        /// thread *after* MLMediaCodecOnFrameAvailableCallback callback has been fired
        /// Note: The returned buffer's color format is multi-planar YUV420 Since our
        /// underlying hardware interops do not support multiplanar formats, advanced
        /// texture features like mipmaping, anisotropic filtering and MSAA will *not*
        /// work on those returned buffers If such advanced texturing features are
        /// required, one has to acquire the YUV buffers as usual and *render* to an
        /// RGB texture and only then, will one be able to enable hardware optimization
        /// for such advanced texture features
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecAcquireNextAvailableFrame(MlApi.MLHandle handle, ref MlApi.MLHandle out_native_buffer);

        /// <summary>
        /// Release a native buffer previously acquired
        ///  MediaCodec instance
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="native_buffer">The native buffer for the frame to release</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// MLResult_Ok Frame was released successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecReleaseFrame(MlApi.MLHandle handle, MlApi.MLHandle native_buffer);

        /// <summary>
        /// Retrieves the 4x4 texture coordinate transform matrix associated with
        /// the last acquired Frame
        ///  MediaCodec instance
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_mtx">A pointer to an array of 16 floats that will receive retrieved
        /// transformation matrix</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// </returns>
        /// <returns>
        /// MLResult_Ok Transformation matrix was returned
        /// </returns>
        /// <remarks>
        /// This transform matrix maps 2D homogeneous texture coordinates of the form
        /// (s, t, 0, 1) with s and t in the inclusive range [0, 1] to the texture
        /// coordinate that should be used to sample that location from the texture
        /// Sampling the texture outside of the range of this transform is undefined
        /// This transform is necessary to compensate for transforms that the stream
        /// content producer may implicitly apply to the content By forcing users of
        /// a GLConsumer to apply this transform we avoid performing an extra
        /// copy of the data that would be needed to hide the transform from the
        /// user
        /// The matrix is stored in column-major order so that it may be passed
        /// directly to OpenGL ES via the glLoadMatrixf or glUniformMatrix4fv
        /// functions
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetFrameTransformationMatrix(MlApi.MLHandle handle, [MarshalAs(UnmanagedType.LPArray, SizeConst = 16)] float[] out_mtx);

        /// <summary>
        /// Retrieves the timestamp associated with the last acquired Frame
        /// The timestamp is in nanoseconds, and is monotonically increasing Its
        /// other semantics (zero point, etc) are codec-dependent and should be
        /// documented by the codec vendor
        ///  MediaCodec instance
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_timestamp">A pointer to user variable for storing retrieved timestamp</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// </returns>
        /// <returns>
        /// MLResult_Ok Timestamp was returned
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetFrameTimestamp(MlApi.MLHandle handle, ref long out_timestamp);

        /// <summary>
        /// Retrieves the QueueBuffer timestamp associated with the last acquired Frame
        /// This timestamp is for profiling purposes only and corresponds to the time when this
        /// frame was queued by internal Codec's producer code The timestamp is in nanoseconds,
        /// and is monotonically increasing Its other semantics (zero point, etc) are codec-
        /// dependent and should by documented by the codec vendor
        ///  MediaCodec instance
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_timestamp">A pointer to user variable for storing retrieved timestamp</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// </returns>
        /// <returns>
        /// MLResult_Ok Timestamp was returned
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetFrameQueueBufferTimestamp(MlApi.MLHandle handle, ref long out_timestamp);

        /// <summary>
        /// Retrieves the last acquired frame number
        /// The frame number is an incrementing counter set to 0 at Codec configuration time
        ///  MediaCodec instance
        /// </summary>
        /// <param name="handle">MLHandle to the</param>
        /// <param name="out_number">A pointer to user variable for storing retrieved frame number</param>
        /// <returns>
        /// MLResult_InvalidParam One of the parameters is invalid
        /// </returns>
        /// <returns>
        /// MLResult_Ok Frame number was returned
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_mediacodec", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLMediaCodecGetFrameNumber(MlApi.MLHandle handle, ref ulong out_number);
    }
}

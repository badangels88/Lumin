//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlRaycast
    {
        /// <summary>
        /// The states of a raycast result
        /// </summary>
        public enum MLRaycastResultState : int
        {
            /// <summary>
            /// The raycast request failed
            /// </summary>
            MLRaycastResultState_RequestFailed = unchecked((int)-1),

            /// <summary>
            /// The ray passed beyond maximum raycast distance and it doesn't hit any surface
            /// </summary>
            MLRaycastResultState_NoCollision,

            /// <summary>
            /// The ray hit unobserved area This will on occur when collide_with_unobserved is set to true
            /// </summary>
            MLRaycastResultState_HitUnobserved,

            /// <summary>
            /// The ray hit only observed area
            /// </summary>
            MLRaycastResultState_HitObserved,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLRaycastResultState_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Request information for a raycast
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLRaycastQuery
        {
            /// <summary>
            /// Origin of ray, in world space
            /// </summary>
            public MlTypes.MLVec3f position;

            /// <summary>
            /// Direction of ray, in world space
            /// Use MLTransformrotation * (0, 0, -1) to use the forward vector of the rig frame in world space
            /// </summary>
            public MlTypes.MLVec3f direction;

            /// <summary>
            /// Up vector, in world space
            /// If multiple rays are to be fired, this is used to determine the coordinate system used to
            /// calculate the directions of those rays; therefore must be orthogonal to the direction vector
            /// Use MLTransformrotation * (0, 1, 0) to use the up vector of the rig frame in world space
            /// This parameter has no effect on a single-point raycast
            /// </summary>
            public MlTypes.MLVec3f up_vector;

            /// <summary>
            /// The number of horizontal rays For single point raycast, set this to 1
            /// </summary>
            public uint width;

            /// <summary>
            /// The number of vertical rays For single point raycast, set this to 1
            /// </summary>
            public uint height;

            /// <summary>
            /// The horizontal field of view, in degrees
            /// </summary>
            public float horizontal_fov_degrees;

            /// <summary>
            /// If @c true, a ray will terminate when encountering an
            /// unobserved area and return a surface or the ray will continue until
            /// it ends or hits a observed surface
            /// </summary>
            [MarshalAs(UnmanagedType.U1)]
            public bool collide_with_unobserved;
        }

        /// <summary>
        /// Result of a raycast
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLRaycastResult
        {
            /// <summary>
            /// Where in the world the collision happened
            /// This field is only valid if the state is either MLRaycastResultState_HitUnobserved
            /// or MLRaycastResultState_HitObserved
            /// </summary>
            public MlTypes.MLVec3f hitpoint;

            /// <summary>
            /// Normal to the surface where the ray collided
            /// This field is only valid if the state is either
            /// MLRaycastResultState_HitUnobserved or MLRaycastResultState_HitObserved
            /// </summary>
            public MlTypes.MLVec3f normal;

            /// <summary>
            /// Confidence of the raycast result Confidence is a non-negative value from 0 to 1 where closer
            /// to 1 indicates a higher quality It is an indication of how confident we are about raycast result
            /// and underlying 3D shape This field is only valid if the state is
            /// either MLRaycastResultState_HitUnobserved or MLRaycastResultState_HitObserved
            /// </summary>
            public float confidence;

            /// <summary>
            /// The raycast result If this field is either MLRaycastResultState_RequestFailed or
            /// MLRaycastResultState_NoCollision, fields in this structure are invalid
            /// </summary>
            public MlRaycast.MLRaycastResultState state;
        }

        /// <summary>
        /// Create the raycast system
        /// </summary>
        /// <param name="out_handle">MLHandle to the created raycast system Only valid if the return value is MLResult_Ok</param>
        /// <returns>
        /// MLResult_InvalidParam Failed due to invalid input parameter
        /// MLResult_Ok Raycast system was created successfully
        /// MLResult_UnspecifiedFailure Failed to create the raycast system due to an internal error
        /// </returns>
        /// <remarks>
        /// This function must be called with the the required settings prior to MLRaycastRequest
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLRaycastCreate(ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Destroy a raycast tracker
        /// </summary>
        /// <param name="tracker_handle">A handle to the raycast system</param>
        /// <returns>
        /// MLResult_Ok Raycast system was destroyed successfully
        /// MLResult_UnspecifiedFailure Failed to destroy the raycast system due to an internal error
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLRaycastDestroy(MlApi.MLHandle tracker_handle);

        /// <summary>
        /// Begin a query to a raycast
        /// </summary>
        /// <param name="tracker_handle">A handle to the tracker created by MLRaycastCreate</param>
        /// <param name="request">Query parameters for the raycast</param>
        /// <param name="out_handle">A handle to an ongoing request</param>
        /// <returns>
        /// MLResult_InvalidParam Failed due to invalid input parameter
        /// MLResult_Ok Request was successfully submitted
        /// MLResult_UnspecifiedFailure Failed due to internal error
        /// </returns>
        /// <remarks>
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLRaycastRequest(MlApi.MLHandle tracker_handle, in MlRaycast.MLRaycastQuery request, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Get the result of a call to MLRaycastRequest
        /// </summary>
        /// <param name="tracker_handle">A handle to the tracker created by MLRaycastCreate</param>
        /// <param name="raycast_request">A handle to the raycast request</param>
        /// <param name="out_result">The target to populate the result</param>
        /// <returns>
        /// MLResult_InvalidParam Failed due to invalid parameter
        /// MLResult_Ok Raycast Result was successfully retrieved
        /// MLResult_Pending Request has not completed This does not indicate a failure
        /// MLResult_UnspecifiedFailure Failed due to internal error
        /// </returns>
        /// <remarks>
        /// After this function has returned successfully, the handle
        /// is invalid
        /// @priv WorldReconstruction
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLRaycastGetResult(MlApi.MLHandle tracker_handle, MlApi.MLHandle raycast_request, ref MlRaycast.MLRaycastResult out_result);
    }
}

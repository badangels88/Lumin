//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlHandTracking
    {
        /// <summary>
        /// Available hand types
        /// </summary>
        public enum MLHandType : int
        {
            /// <summary>
            /// Left hand
            /// </summary>
            MLHandType_Left,

            /// <summary>
            /// Right hand
            /// </summary>
            MLHandType_Right,

            /// <summary>
            /// Number of hands
            /// </summary>
            MLHandType_Count,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLHandType_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        public const int MLHandTrackingStaticData_MaxKeyPoints = unchecked((int)24);

        /// <summary>
        /// Static key pose types which are available when both hands are separated
        /// @apilevel 6
        /// </summary>
        public enum MLHandTrackingKeyPose : int
        {
            /// <summary>
            /// Index finger
            /// </summary>
            MLHandTrackingKeyPose_Finger = unchecked((int)0),

            /// <summary>
            /// A closed fist
            /// </summary>
            MLHandTrackingKeyPose_Fist = unchecked((int)1),

            /// <summary>
            /// A pinch
            /// </summary>
            MLHandTrackingKeyPose_Pinch = unchecked((int)2),

            /// <summary>
            /// A closed fist with the thumb pointed up
            /// </summary>
            MLHandTrackingKeyPose_Thumb = unchecked((int)3),

            /// <summary>
            /// An L shape
            /// </summary>
            MLHandTrackingKeyPose_L = unchecked((int)4),

            /// <summary>
            /// An open hand with palm facing away or palm facing towards the user
            /// </summary>
            MLHandTrackingKeyPose_OpenHand = unchecked((int)5),

            /// <summary>
            /// Deprecated Please use MLHandTrackingKeyPose_OpenHand
            /// </summary>
            MLHandTrackingKeyPose_OpenHandBack = unchecked((int)5),

            /// <summary>
            /// A pinch with all fingers, except the index finger and the thumb, extended out
            /// </summary>
            MLHandTrackingKeyPose_Ok = unchecked((int)6),

            /// <summary>
            /// A rounded 'C' alphabet shape
            /// </summary>
            MLHandTrackingKeyPose_C = unchecked((int)7),

            /// <summary>
            /// No pose was recognized
            /// </summary>
            MLHandTrackingKeyPose_NoPose = unchecked((int)8),

            /// <summary>
            /// No hand was detected Should be the last pose
            /// </summary>
            MLHandTrackingKeyPose_NoHand = unchecked((int)9),

            /// <summary>
            /// Number of static poses
            /// </summary>
            MLHandTrackingKeyPose_Count = unchecked((int)10),

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLHandTrackingKeyPose_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Configured level for keypoints filtering of keypoints and hand centers
        /// </summary>
        public enum MLKeypointFilterLevel : int
        {
            /// <summary>
            /// Default value, no filtering is done, the points are raw
            /// </summary>
            MLKeypointFilterLevel_0,

            /// <summary>
            /// Some smoothing at the cost of latency
            /// </summary>
            MLKeypointFilterLevel_1,

            /// <summary>
            /// Predictive smoothing, at higher cost of latency
            /// </summary>
            MLKeypointFilterLevel_2,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLKeypointFilterLevel_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Configured level of filtering for static poses
        /// </summary>
        public enum MLPoseFilterLevel : int
        {
            /// <summary>
            /// Default value, No filtering, the poses are raw
            /// </summary>
            MLPoseFilterLevel_0,

            /// <summary>
            /// Some robustness to flicker at some cost of latency
            /// </summary>
            MLPoseFilterLevel_1,

            /// <summary>
            /// More robust to flicker at higher latency cost
            /// </summary>
            MLPoseFilterLevel_2,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLPoseFilterLevel_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Keypoint data structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLKeyPointState
        {
            /// <summary>
            /// Keypoint coordinate frame
            /// </summary>
            public MlCoordinateFrameUid.MLCoordinateFrameUID frame_id;

            /// <summary>
            /// Keypoint is valid or not
            /// </summary>
            [MarshalAs(UnmanagedType.U1)]
            public bool is_valid;
        }

        /// <summary>
        /// Thumb data structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLThumbState
        {
            /// <summary>
            /// Tip of finger
            /// </summary>
            public MlHandTracking.MLKeyPointState tip;

            /// <summary>
            /// Inter-phalengial
            /// </summary>
            public MlHandTracking.MLKeyPointState ip;

            /// <summary>
            /// Meta-carpal phalengial
            /// </summary>
            public MlHandTracking.MLKeyPointState mcp;

            /// <summary>
            /// Carpals-Meta-carpal
            /// </summary>
            public MlHandTracking.MLKeyPointState cmc;
        }

        /// <summary>
        /// Finger data structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLFingerState
        {
            /// <summary>
            /// Tip of finger
            /// </summary>
            public MlHandTracking.MLKeyPointState tip;

            /// <summary>
            /// Distal-inter-phalengial
            /// </summary>
            public MlHandTracking.MLKeyPointState dip;

            /// <summary>
            /// Proximal-inter-phalengial
            /// </summary>
            public MlHandTracking.MLKeyPointState pip;

            /// <summary>
            /// Meta-carpal phalengial
            /// </summary>
            public MlHandTracking.MLKeyPointState mcp;
        }

        /// <summary>
        /// Wrist data structure
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLWristState
        {
            /// <summary>
            /// Wrist center
            /// </summary>
            public MlHandTracking.MLKeyPointState center;

            /// <summary>
            /// Ulnar-sided wrist
            /// </summary>
            public MlHandTracking.MLKeyPointState ulnar;

            /// <summary>
            /// Radial-sided wrist
            /// </summary>
            public MlHandTracking.MLKeyPointState radial;
        }

        /// <summary>
        /// Static information for one hand
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLHandTrackingStaticHandState
        {
            /// <summary>
            /// The keypoints on thumb
            /// </summary>
            public MlHandTracking.MLThumbState thumb;

            /// <summary>
            /// The keypoints on index finger
            /// </summary>
            public MlHandTracking.MLFingerState index;

            /// <summary>
            /// The keypoints on middle finger
            /// </summary>
            public MlHandTracking.MLFingerState middle;

            /// <summary>
            /// The keypoints on ring finger
            /// </summary>
            public MlHandTracking.MLFingerState ring;

            /// <summary>
            /// The keypoints on pinky finger
            /// </summary>
            public MlHandTracking.MLFingerState pinky;

            /// <summary>
            /// The keypoints on the wrist
            /// </summary>
            public MlHandTracking.MLWristState wrist;

            /// <summary>
            /// Hand center
            /// </summary>
            public MlHandTracking.MLKeyPointState hand_center;
        }

        /// <summary>
        /// Static information about a hand tracker Populate this structure with
        /// MLHandTrackingGetStaticData
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLHandTrackingStaticData
        {
            /// <summary>
            /// Left hand frame
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 24)]
            public MlHandTracking.MLKeyPointState[] left_frame;

            /// <summary>
            /// Left hand state
            /// </summary>
            public MlHandTracking.MLHandTrackingStaticHandState left;

            /// <summary>
            /// Right hand frame
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 24)]
            public MlHandTracking.MLKeyPointState[] right_frame;

            /// <summary>
            /// Right hand state
            /// </summary>
            public MlHandTracking.MLHandTrackingStaticHandState right;
        }

        /// <summary>
        /// Hand state
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLHandTrackingHandState
        {
            /// <summary>
            /// The static keypose currently being performed by the single hand
            /// </summary>
            public MlHandTracking.MLHandTrackingKeyPose keypose;

            /// <summary>
            /// The confidence level of a hand is present in the scene
            /// </summary>
            /// <remarks>
            /// Value is between [0, 1], 0 is low, 1 is high degree of confidence
            /// </remarks>
            public float hand_confidence;

            /// <summary>
            /// The confidence for all poses
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 10)]
            public float[] keypose_confidence;

            /// <summary>
            /// The filtered confidence for all poses
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 10)]
            public float[] keypose_confidence_filtered;

            /// <summary>
            /// Mask indicates if a keypoint is present or not
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U1, SizeConst = 24)]
            public bool[] keypoints_mask;

            /// <summary>
            /// Normalized position of hand center within depth-sensor view Each dimension is between [-1, 1]
            /// </summary>
            public MlTypes.MLVec3f hand_center_normalized;
        }

        /// <summary>
        /// Data which is received when querying hand tracker from MLHandTrackingGetData
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLHandTrackingData
        {
            /// <summary>
            /// Hand tracker state of the left hand
            /// </summary>
            public MlHandTracking.MLHandTrackingHandState left_hand_state;

            /// <summary>
            /// Hand tracker state of the right hand
            /// </summary>
            public MlHandTracking.MLHandTrackingHandState right_hand_state;
        }

        /// <summary>
        /// Configuration of the hand tracking system This is used to activate or
        /// deactivate the poses the system will look for
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLHandTrackingConfiguration
        {
            /// <summary>
            /// Configuration for the static poses True will enable the pose to be
            /// tracked by the system, false will disable it Note that the size of keypose_config
            /// is set to MLHandTrackingKeyPose_Count-1 Disabling NoHand is not allowed
            /// If a disabled pose is performed, the most probable enabled pose will be reported
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U1, SizeConst = 9)]
            public bool[] keypose_config;

            /// <summary>
            /// True activates hand tracking False deactivates the handtracking pipeline
            /// entirely and no recognition will take place
            /// </summary>
            [MarshalAs(UnmanagedType.U1)]
            public bool handtracking_pipeline_enabled;

            /// <summary>
            /// Keypoint filter levels
            /// </summary>
            public MlHandTracking.MLKeypointFilterLevel keypoints_filter_level;

            /// <summary>
            /// Pose filter levels
            /// </summary>
            public MlHandTracking.MLPoseFilterLevel pose_filter_level;
        }

        /// <summary>
        /// Creates a hand tracker
        /// </summary>
        /// <param name="out_handle">A handle which can be used with MLHandTrackingGetData to get
        /// information about the hand, or ML_INVALID_HANDLE if the tracker
        /// could not be created</param>
        /// <returns>
        /// MLResult_InvalidParam out_handle is null
        /// MLResult_Ok The tracker was created successfully
        /// MLResult_PrivilegeDenied The application lacks privilege
        /// MLResult_UnspecifiedFailure It failed to create the tracker
        /// </returns>
        /// <remarks>
        /// @priv LowLatencyLightwear
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHandTrackingCreate(ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Destroys a hand tracker
        /// </summary>
        /// <param name="hand_tracker">A handle to a Hand Tracker created by MLHandTrackingCreate</param>
        /// <returns>
        /// MLResult_Ok It successfully destroyed the tracker
        /// MLResult_UnspecifiedFailure It failed to destroy the tracker
        /// </returns>
        /// <remarks>
        /// @priv LowLatencyLightwear
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHandTrackingDestroy(MlApi.MLHandle hand_tracker);

        /// <summary>
        /// Queries the current state of the hand tracker
        /// </summary>
        /// <param name="hand_tracker">A handle to a Hand Tracker created by MLHandTrackingCreate</param>
        /// <param name="out_data">Pointer to a variable that receives information about the tracked hands</param>
        /// <returns>
        /// MLResult_InvalidParam out_data is null
        /// MLResult_Ok The hand information was available and the information in out_data is valid
        /// MLResult_UnspecifiedFailure It failed to get the hand information
        /// </returns>
        /// <remarks>
        /// @priv LowLatencyLightwear
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHandTrackingGetData(MlApi.MLHandle hand_tracker, ref MlHandTracking.MLHandTrackingData out_data);

        /// <summary>
        /// Gets static information about hand tracking
        /// </summary>
        /// <param name="hand_tracker">A handle to a Hand Tracker created by MLHandTrackingCreate</param>
        /// <param name="out_data">Pointer to a variable that receives static data about the hand tracker</param>
        /// <returns>
        /// MLResult_InvalidParam out_data is null
        /// MLResult_Ok The hand information was available and the information in out_data is valid
        /// MLResult_PrivilegeDenied The application lacks privilege
        /// MLResult_UnspecifiedFailure It failed to get the hand information
        /// </returns>
        /// <remarks>
        /// @priv LowLatencyLightwear, GesturesSubscribe
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHandTrackingGetStaticData(MlApi.MLHandle hand_tracker, ref MlHandTracking.MLHandTrackingStaticData out_data);

        /// <summary>
        /// Sets the configuration of the hand tracking system
        /// </summary>
        /// <param name="hand_tracker">A handle to a Hand Tracker created by MLHandTrackingCreate</param>
        /// <param name="out_config">Pointer to a variable that contains the configuration</param>
        /// <returns>
        /// MLResult_InvalidParam config is null
        /// MLResult_Ok It successfully updated the hand configuration
        /// MLResult_PrivilegeDenied The application lacks privilege
        /// MLResult_UnspecifiedFailure It failed to update the hand configuration
        /// </returns>
        /// <remarks>
        /// @priv GesturesConfig
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHandTrackingSetConfiguration(MlApi.MLHandle hand_tracker, in MlHandTracking.MLHandTrackingConfiguration out_config);

        /// <summary>
        /// Gets the current configuration of the hand tracking system
        /// </summary>
        /// <param name="hand_tracker">A handle to a Hand Tracker created by MLHandTrackingCreate</param>
        /// <param name="out_config">Pointer to a variable that receives information about the current configuration</param>
        /// <returns>
        /// MLResult_InvalidParam out_config is null
        /// MLResult_Ok The information in out_config is valid
        /// MLResult_PrivilegeDenied The application lacks privilege
        /// MLResult_UnspecifiedFailure It failed to get the current configuration
        /// </returns>
        /// <remarks>
        /// @priv GesturesConfig, GesturesSubscribe
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLHandTrackingGetConfiguration(MlApi.MLHandle hand_tracker, ref MlHandTracking.MLHandTrackingConfiguration out_config);
    }
}

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlInput
    {
        /// <summary>
        ///  Input
        /// APIs for the Input system
        /// </summary>
        /// <remarks>
        /// \
        /// {
        /// </remarks>
        public enum __AnonymousCppEnum_ml_input_1966 : int
        {
            /// <summary>
            /// Maximum recognized number of input controllers
            /// </summary>
            MLInput_MaxControllers = unchecked((int)2),

            /// <summary>
            /// Maximum recognized number of controller touchpad touches
            /// </summary>
            MLInput_MaxControllerTouchpadTouches = unchecked((int)2),
        }

        /// <summary>
        /// Touchpad gesture state
        /// </summary>
        public enum MLInputControllerTouchpadGestureState : int
        {
            /// <summary>
            /// End(Default)
            /// </summary>
            MLInputControllerTouchpadGestureState_End,

            /// <summary>
            /// Continue
            /// </summary>
            MLInputControllerTouchpadGestureState_Continue,

            /// <summary>
            /// Start
            /// </summary>
            MLInputControllerTouchpadGestureState_Start,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerTouchpadGestureState_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Recognized touchpad gesture types
        /// </summary>
        public enum MLInputControllerTouchpadGestureType : int
        {
            /// <summary>
            /// None
            /// </summary>
            MLInputControllerTouchpadGestureType_None,

            /// <summary>
            /// Tap
            /// </summary>
            MLInputControllerTouchpadGestureType_Tap,

            /// <summary>
            /// Force tap down
            /// </summary>
            MLInputControllerTouchpadGestureType_ForceTapDown,

            /// <summary>
            /// Force tap up
            /// </summary>
            MLInputControllerTouchpadGestureType_ForceTapUp,

            /// <summary>
            /// Force dwell
            /// </summary>
            MLInputControllerTouchpadGestureType_ForceDwell,

            /// <summary>
            /// Second force down
            /// </summary>
            MLInputControllerTouchpadGestureType_SecondForceDown,

            /// <summary>
            /// Long hold
            /// </summary>
            MLInputControllerTouchpadGestureType_LongHold,

            /// <summary>
            /// Radial scroll
            /// </summary>
            MLInputControllerTouchpadGestureType_RadialScroll,

            /// <summary>
            /// Swipe
            /// </summary>
            MLInputControllerTouchpadGestureType_Swipe,

            /// <summary>
            /// Scroll
            /// </summary>
            MLInputControllerTouchpadGestureType_Scroll,

            /// <summary>
            /// Pinch
            /// </summary>
            MLInputControllerTouchpadGestureType_Pinch,

            /// <summary>
            /// Number of gesture types
            /// </summary>
            MLInputControllerTouchpadGestureType_Count,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerTouchpadGestureType_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Direction of touchpad gesture
        /// </summary>
        public enum MLInputControllerTouchpadGestureDirection : int
        {
            /// <summary>
            /// None
            /// </summary>
            MLInputControllerTouchpadGestureDirection_None,

            /// <summary>
            /// Up
            /// </summary>
            MLInputControllerTouchpadGestureDirection_Up,

            /// <summary>
            /// Down
            /// </summary>
            MLInputControllerTouchpadGestureDirection_Down,

            /// <summary>
            /// Left
            /// </summary>
            MLInputControllerTouchpadGestureDirection_Left,

            /// <summary>
            /// Right
            /// </summary>
            MLInputControllerTouchpadGestureDirection_Right,

            /// <summary>
            /// In
            /// </summary>
            MLInputControllerTouchpadGestureDirection_In,

            /// <summary>
            /// Out
            /// </summary>
            MLInputControllerTouchpadGestureDirection_Out,

            /// <summary>
            /// Clockwise
            /// </summary>
            MLInputControllerTouchpadGestureDirection_Clockwise,

            /// <summary>
            /// Counter clockwise
            /// </summary>
            MLInputControllerTouchpadGestureDirection_CounterClockwise,

            /// <summary>
            /// Number of directions
            /// </summary>
            MLInputControllerTouchpadGestureDirection_Count,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerTouchpadGestureDirection_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Types of input controllers recognized by Magic Leap platform
        /// </summary>
        public enum MLInputControllerType : int
        {
            /// <summary>
            /// None
            /// </summary>
            MLInputControllerType_None,

            /// <summary>
            /// Device
            /// </summary>
            MLInputControllerType_Device,

            /// <summary>
            /// Mobile app
            /// </summary>
            MLInputControllerType_MobileApp,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerType_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Degrees-of-freedom mode of input controller
        /// </summary>
        public enum MLInputControllerDof : int
        {
            /// <summary>
            /// None
            /// </summary>
            MLInputControllerDof_None,

            /// <summary>
            /// 3DoF
            /// </summary>
            MLInputControllerDof_3,

            /// <summary>
            /// 6DoF
            /// </summary>
            MLInputControllerDof_6,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerDof_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Buttons on input controllers (Magic Leap device and Mobile Companion App)
        /// </summary>
        public enum MLInputControllerButton : int
        {
            MLInputControllerButton_None,

            /// <summary>
/// 
            /// </summary>
            /// <remarks>
            /// Move button is obsolete
            /// </remarks>
            MLInputControllerButton_Move,

            /// <summary>
/// 
            /// </summary>
            /// <remarks>
            /// App button is obsolete
            /// </remarks>
            MLInputControllerButton_App,

            /// <summary>
            /// Bumper
            /// </summary>
            MLInputControllerButton_Bumper,

            /// <summary>
            /// Home tap
            /// </summary>
            MLInputControllerButton_HomeTap,

            /// <summary>
            /// Number of buttons
            /// </summary>
            MLInputControllerButton_Count,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerButton_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Feedback patterns for LED target
        /// </summary>
        public enum MLInputControllerFeedbackPatternLED : int
        {
            MLInputControllerFeedbackPatternLED_None,

            MLInputControllerFeedbackPatternLED_Clock1,

            MLInputControllerFeedbackPatternLED_Clock2,

            MLInputControllerFeedbackPatternLED_Clock3,

            MLInputControllerFeedbackPatternLED_Clock4,

            MLInputControllerFeedbackPatternLED_Clock5,

            MLInputControllerFeedbackPatternLED_Clock6,

            MLInputControllerFeedbackPatternLED_Clock7,

            MLInputControllerFeedbackPatternLED_Clock8,

            MLInputControllerFeedbackPatternLED_Clock9,

            MLInputControllerFeedbackPatternLED_Clock10,

            MLInputControllerFeedbackPatternLED_Clock11,

            MLInputControllerFeedbackPatternLED_Clock12,

            MLInputControllerFeedbackPatternLED_Clock1And7,

            MLInputControllerFeedbackPatternLED_Clock2And8,

            MLInputControllerFeedbackPatternLED_Clock3And9,

            MLInputControllerFeedbackPatternLED_Clock4And10,

            MLInputControllerFeedbackPatternLED_Clock5And11,

            MLInputControllerFeedbackPatternLED_Clock6And12,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerFeedbackPatternLED_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Feedback effects for LED target
        /// </summary>
        public enum MLInputControllerFeedbackEffectLED : int
        {
            MLInputControllerFeedbackEffectLED_RotateCW,

            MLInputControllerFeedbackEffectLED_RotateCCW,

            MLInputControllerFeedbackEffectLED_Pulse,

            MLInputControllerFeedbackEffectLED_PaintCW,

            MLInputControllerFeedbackEffectLED_PaintCCW,

            MLInputControllerFeedbackEffectLED_Blink,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerFeedbackEffectLED_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Feedback colors for LED target
        /// </summary>
        public enum MLInputControllerFeedbackColorLED : int
        {
            MLInputControllerFeedbackColorLED_BrightMissionRed,

            MLInputControllerFeedbackColorLED_PastelMissionRed,

            MLInputControllerFeedbackColorLED_BrightFloridaOrange,

            MLInputControllerFeedbackColorLED_PastelFloridaOrange,

            MLInputControllerFeedbackColorLED_BrightLunaYellow,

            MLInputControllerFeedbackColorLED_PastelLunaYellow,

            MLInputControllerFeedbackColorLED_BrightNebulaPink,

            MLInputControllerFeedbackColorLED_PastelNebulaPink,

            MLInputControllerFeedbackColorLED_BrightCosmicPurple,

            MLInputControllerFeedbackColorLED_PastelCosmicPurple,

            MLInputControllerFeedbackColorLED_BrightMysticBlue,

            MLInputControllerFeedbackColorLED_PastelMysticBlue,

            MLInputControllerFeedbackColorLED_BrightCelestialBlue,

            MLInputControllerFeedbackColorLED_PastelCelestialBlue,

            MLInputControllerFeedbackColorLED_BrightShaggleGreen,

            MLInputControllerFeedbackColorLED_PastelShaggleGreen,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerFeedbackColorLED_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Feedback effect speed for LED target
        /// </summary>
        public enum MLInputControllerFeedbackEffectSpeedLED : int
        {
            MLInputControllerFeedbackEffectSpeedLED_Slow,

            MLInputControllerFeedbackEffectSpeedLED_Medium,

            MLInputControllerFeedbackEffectSpeedLED_Fast,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerFeedbackEffectSpeedLED_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Feedback patterns for vibration, which can be applied to touchpad and body
        /// </summary>
        public enum MLInputControllerFeedbackPatternVibe : int
        {
            MLInputControllerFeedbackPatternVibe_None,

            MLInputControllerFeedbackPatternVibe_Click,

            MLInputControllerFeedbackPatternVibe_Bump,

            MLInputControllerFeedbackPatternVibe_DoubleClick,

            MLInputControllerFeedbackPatternVibe_Buzz,

            MLInputControllerFeedbackPatternVibe_Tick,

            MLInputControllerFeedbackPatternVibe_ForceDown,

            MLInputControllerFeedbackPatternVibe_ForceUp,

            MLInputControllerFeedbackPatternVibe_ForceDwell,

            MLInputControllerFeedbackPatternVibe_SecondForceDown,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerFeedbackPatternVibe_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Discrete intensity of feedback
        /// </summary>
        public enum MLInputControllerFeedbackIntensity : int
        {
            MLInputControllerFeedbackIntensity_Low,

            MLInputControllerFeedbackIntensity_Medium,

            MLInputControllerFeedbackIntensity_High,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLInputControllerFeedbackIntensity_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Types of input tablet devices recognized
        /// @apilevel 5
        /// </summary>
        public enum MLInputTabletDeviceType : int
        {
            MLInputTabletDeviceType_Unknown = unchecked((int)0),

            MLInputTabletDeviceType_Wacom = unchecked((int)1),

            MLInputTabletDeviceType_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Types of tools used with the tablet device
        /// @apilevel 5
        /// </summary>
        public enum MLInputTabletDeviceToolType : int
        {
            MLInputTabletDeviceToolType_Unknown = unchecked((int)0),

            MLInputTabletDeviceToolType_Pen = unchecked((int)1),

            MLInputTabletDeviceToolType_Eraser = unchecked((int)2),

            MLInputTabletDeviceTootlType_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Buttons on input tablet device
        /// @apilevel 5
        /// </summary>
        public enum MLInputTabletDeviceButton : int
        {
            MLInputTabletDeviceButton_Unknown,

            MLInputTabletDeviceButton_Button1,

            MLInputTabletDeviceButton_Button2,

            MLInputTabletDeviceButton_Button3,

            MLInputTabletDeviceButton_Button4,

            MLInputTabletDeviceButton_Button5,

            MLInputTabletDeviceButton_Button6,

            MLInputTabletDeviceButton_Button7,

            MLInputTabletDeviceButton_Button8,

            MLInputTabletDeviceButton_Button9,

            MLInputTabletDeviceButton_Button10,

            MLInputTabletDeviceButton_Button11,

            MLInputTabletDeviceButton_Button12,

            MLInputTabletDeviceButton_Count,

            MLInputTabletDeviceButton_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Mask value to determine the validity of MLInputTabletDeviceStateMask
        /// @apilevel 5
        /// </summary>
        [Flags]
        public enum MLInputTabletDeviceStateMask : int
        {
            /// <summary>
            /// Mask for determinig the validity of the additional pen data
            /// </summary>
            MLInputTabletDeviceStateMask_HasType = unchecked((int)1 << (int) 0),

            /// <summary>
            /// Mask for determinig the validity of the additional pen data
            /// </summary>
            MLInputTabletDeviceStateMask_HasToolType = unchecked((int)1 << (int) 1),

            /// <summary>
            /// Mask for determinig the validity of the additional pen data
            /// </summary>
            MLInputTabletDeviceStateMask_HasPenTouchPosAndForce = unchecked((int)1 << (int) 2),

            /// <summary>
            /// Mask for determinig the validity of the additional pen data
            /// </summary>
            MLInputTabletDeviceStateMask_HasAdditionalPenTouchData = unchecked((int)1 << (int) 3),

            /// <summary>
            /// Mask for determinig the validity of the additional pen data
            /// </summary>
            MLInputTabletDeviceStateMask_HasPenTouchActive = unchecked((int)1 << (int) 4),

            /// <summary>
            /// Mask for determinig the validity of the additional pen data
            /// </summary>
            MLInputTabletDeviceStateMask_HasConnectionState = unchecked((int)1 << (int) 5),

            /// <summary>
            /// Mask for determinig the validity of the additional pen data
            /// </summary>
            MLInputTabletDeviceStateMask_HasPenDistance = unchecked((int)1 << (int) 6),

            /// <summary>
            /// Mask for determinig the validity of the additional pen data
            /// </summary>
            MLInputTabletDeviceStateMask_HasTimestamp = unchecked((int)1 << (int) 7),
        }

        /// <summary>
        /// Information about a recognized touchpad gesture
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputControllerTouchpadGesture
        {
            /// <summary>
            /// Gesture position (x,y) and force (z)
            /// Position is in the [-10,10] range and force is in the [00,10] range
            /// </summary>
            public MlTypes.MLVec3f pos_and_force;

            /// <summary>
            /// Type of gesture
            /// </summary>
            public MlInput.MLInputControllerTouchpadGestureType type;

            /// <summary>
            /// Direction of gesture
            /// </summary>
            public MlInput.MLInputControllerTouchpadGestureDirection direction;

            /// <summary>
            /// Speed of gesture Note that this takes on different meanings depending
            /// on the gesture type being performed:
            /// - For radial gestures, this will be the angular speed around the axis
            /// - For pinch gestures, this will be the speed at which the distance
            /// between fingers is changing The touchpad is defined as having extents
            /// of [-10,10] so touchpad distance has a range of [00,20]; this value
            /// will be in touchpad distance per second
            /// </summary>
            public float speed;

            /// <summary>
            /// For radial gestures, this is the absolute value of the angle For scroll
            /// and pinch gestures, this is the absolute distance traveled in touchpad
            /// distance The touchpad is defined as having extents of [-10,10] so
            /// this distance has a range of [00,20]
            /// </summary>
            public float distance;

            /// <summary>
            /// Distance between the two fingers performing the gestures in touchpad
            /// distance The touchpad is defined as having extents of [-10,10] so
            /// this distance has a range of [00,20]
            /// </summary>
            public float finger_gap;

            /// <summary>
            /// For radial gestures, this is the radius of the gesture The touchpad
            /// is defined as having extents of [-10,10] so this radius has a range
            /// of [00,20]
            /// </summary>
            public float radius;

            /// <summary>
            /// Angle from the center of the touchpad to the finger
            /// </summary>
            public float angle;
        }

        /// <summary>
        /// A structure containing callbacks for input controller events The final
        /// parameter to all the callbacks is a void *, which will point to whatever
        /// payload data the user provides in MLInputSetControllerCallbacks
        /// Individual callbacks which are not required by the client can be NULL
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputControllerCallbacks
        {
            public MlInput.MLInputControllerCallbacks.on_touchpad_gesture_start_delegate on_touchpad_gesture_start;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_touchpad_gesture_start_delegate(byte controller_id, in MlInput.MLInputControllerTouchpadGesture touchpad_gesture, IntPtr data);

            public MlInput.MLInputControllerCallbacks.on_touchpad_gesture_continue_delegate on_touchpad_gesture_continue;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_touchpad_gesture_continue_delegate(byte controller_id, in MlInput.MLInputControllerTouchpadGesture touchpad_gesture, IntPtr data);

            public MlInput.MLInputControllerCallbacks.on_touchpad_gesture_end_delegate on_touchpad_gesture_end;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_touchpad_gesture_end_delegate(byte controller_id, in MlInput.MLInputControllerTouchpadGesture touchpad_gesture, IntPtr data);

            public MlInput.MLInputControllerCallbacks.on_button_down_delegate on_button_down;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_button_down_delegate(byte controller_id, MlInput.MLInputControllerButton button, IntPtr data);

            public MlInput.MLInputControllerCallbacks.on_button_up_delegate on_button_up;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_button_up_delegate(byte controller_id, MlInput.MLInputControllerButton button, IntPtr data);

            public MlInput.MLInputControllerCallbacks.on_connect_delegate on_connect;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_connect_delegate(byte controller_id, IntPtr data);

            public MlInput.MLInputControllerCallbacks.on_disconnect_delegate on_disconnect;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_disconnect_delegate(byte controller_id, IntPtr data);
        }

        /// <summary>
        /// A structure containing information about the current state of an input controller
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputControllerState
        {
            /// <summary>
            /// 6DoF position and orientation of the controller
            /// </summary>
            public MlTypes.MLQuaternionf orientation;

            public MlTypes.MLVec3f position;

            /// <summary>
            /// Current touch position (x,y) and force (z)
            /// Position is in the [-10,10] range and force is in the [00,10] range
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 2)]
            public MlTypes.MLVec3f[] touch_pos_and_force;

            /// <summary>
            /// Normalized trigger value [00,10]
            /// </summary>
            public float trigger_normalized;

            /// <summary>
            /// Button states
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U1, SizeConst = 5)]
            public bool[] button_state;

            /// <summary>
            /// Is touch active
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U1, SizeConst = 2)]
            public bool[] is_touch_active;

            /// <summary>
            /// If this controller is connected
            /// </summary>
            [MarshalAs(UnmanagedType.U1)]
            public bool is_connected;

            /// <summary>
            /// Current touchpad gesture
            /// </summary>
            public MlInput.MLInputControllerTouchpadGesture touchpad_gesture;

            /// <summary>
            /// Current touchpad gesture state
            /// </summary>
            public MlInput.MLInputControllerTouchpadGestureState touchpad_gesture_state;

            /// <summary>
            /// Type of this controller
            /// </summary>
            public MlInput.MLInputControllerType type;

            /// <summary>
            /// Current degrees of freedom mode of the controller
            /// </summary>
            public MlInput.MLInputControllerDof dof;

            /// <summary>
            /// Hardware index of this controller If it is a physical controller this
            /// will be either 0 or 1 If it is MLMA it will be 0xFF
            /// </summary>
            public byte hardware_index;
        }

        /// <summary>
        /// A structure containing callbacks for input keyboard events The final
        /// parameter to all the callbacks is a void *, which will point to whatever
        /// payload data the user provides in MLInputSetKeyboardCallbacks Individual
        /// callbacks which are not required by the client can be NULL
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputKeyboardCallbacks
        {
            public MlInput.MLInputKeyboardCallbacks.on_char_delegate on_char;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_char_delegate(uint char_utf32, IntPtr data);

            public MlInput.MLInputKeyboardCallbacks.on_key_down_delegate on_key_down;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_key_down_delegate(MlKeycodes.MLKeyCode key_code, uint modifier_mask, IntPtr data);

            public MlInput.MLInputKeyboardCallbacks.on_key_up_delegate on_key_up;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_key_up_delegate(MlKeycodes.MLKeyCode key_code, uint modifier_mask, IntPtr data);
        }

        /// <summary>
        /// A structure containing information about the current keyboard state Note that
        /// all connected keyboards will be muxed together into one state
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputKeyboardState
        {
            /// <summary>
            /// Current state of keys: true if currently pressed, false otherwise
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U1, SizeConst = 280)]
            public bool[] key_state;

            /// <summary>
            /// Currently active modifier keys
            /// </summary>
            public uint modifier_mask;
        }

        /// <summary>
        /// A structure containing information about the state of the tablet device
        /// @apilevel 5
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputTabletDeviceState
        {
            /// <summary>
            /// Version of this structure
            /// </summary>
            public uint version;

            /// <summary>
            /// Type of this tablet device
            /// </summary>
            public MlInput.MLInputTabletDeviceType type;

            /// <summary>
            /// Type of tool used with the tablet
            /// </summary>
            public MlInput.MLInputTabletDeviceToolType tool_type;

            /// <summary>
            /// Current touch position (x,y) and force (z)
            /// Position is in the [-10,10] range and force is in the [00,10] range
            /// </summary>
            public MlTypes.MLVec3f pen_touch_pos_and_force;

            /// <summary>
            /// Additional coordinate values (x, y, z)
            /// It could contain data specific to the device type
            /// For example, it could hold tilt values while using pen
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 3)]
            public int[] additional_pen_touch_data;

            /// <summary>
            /// Is touch active
            /// </summary>
            [MarshalAs(UnmanagedType.U1)]
            public bool is_pen_touch_active;

            /// <summary>
            /// If this tablet is connected
            /// </summary>
            [MarshalAs(UnmanagedType.U1)]
            public bool is_connected;

            /// <summary>
            /// Distance between pen and tablet
            /// </summary>
            public float pen_distance;

            /// <summary>
            /// Time stamp of the event
            /// </summary>
            public ulong timestamp;

            /// <summary>
            /// Flags to denote which of the above fields are valid
            /// MLInputTabletDeviceStateMask defines the bitmap
            /// </summary>
            public uint valid_fields_flag;
        }

        /// <summary>
        /// Stores a list of MLInputTabletDeviceState
        /// @apilevel 5
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputTabletDeviceStatesList
        {
            /// <summary>
            /// Version of this structure
            /// </summary>
            public uint version;

            /// <summary>
            /// Number of tablet device states in this list
            /// </summary>
            public uint count;

            /// <summary>
            /// Pointer referring to the array of MLInputTabletDeviceState
            /// </summary>
            public IntPtr data;
        }

        /// <summary>
        /// A structure to contain information about the connected devices
        /// @apilevel 5
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputConnectedDevicesList
        {
            /// <summary>
            /// Version of this structure
            /// </summary>
            public uint version;

            /// <summary>
            /// Number of connected controllers
            /// </summary>
            public uint connected_controller_count;

            /// <summary>
            /// Pointer to the array of connected controller IDs
            /// </summary>
            public IntPtr connected_controller_ids;

            /// <summary>
            /// Number of connected tablet devices
            /// </summary>
            public uint connected_tablet_device_count;

            /// <summary>
            /// Pointer to the array of connected tablet device IDs
            /// </summary>
            public IntPtr connected_tablet_device_ids;
        }

        /// <summary>
        /// A structure containing callbacks for input tablet device events
        /// </summary>
        /// <remarks>
        /// The final parameter to all the callbacks is a void *, which will point to whatever
        /// payload data the user provides in MLInputSetTabletDeviceCallbacks Individual
        /// callbacks which are not required by the client can be NULL
        /// @apilevel 5
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputTabletDeviceCallbacks
        {
            /// <summary>
            /// Version of this callback
            /// </summary>
            public uint version;

            public MlInput.MLInputTabletDeviceCallbacks.on_pen_touch_event_delegate on_pen_touch_event;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_pen_touch_event_delegate(byte tablet_device_id, in MlInput.MLInputTabletDeviceState tablet_device_state, IntPtr data);

            public MlInput.MLInputTabletDeviceCallbacks.on_touch_ring_event_delegate on_touch_ring_event;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_touch_ring_event_delegate(byte tablet_device_id, int touch_ring_value, ulong timestamp, IntPtr data);

            public MlInput.MLInputTabletDeviceCallbacks.on_button_down_delegate on_button_down;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_button_down_delegate(byte tablet_device_id, MlInput.MLInputTabletDeviceButton tablet_device_button, ulong timestamp, IntPtr data);

            public MlInput.MLInputTabletDeviceCallbacks.on_button_up_delegate on_button_up;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_button_up_delegate(byte tablet_device_id, MlInput.MLInputTabletDeviceButton tablet_device_button, ulong timestamp, IntPtr data);

            public MlInput.MLInputTabletDeviceCallbacks.on_connect_delegate on_connect;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_connect_delegate(byte tablet_device_id, IntPtr data);

            public MlInput.MLInputTabletDeviceCallbacks.on_disconnect_delegate on_disconnect;

            [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
            public delegate void on_disconnect_delegate(byte tablet_device_id, IntPtr data);
        }

        /// <summary>
        /// Desired configuration of the input system
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLInputConfiguration
        {
            /// <summary>
            /// Desired degrees-of-freedom mode of each controller
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 2)]
            public MlInput.MLInputControllerDof[] dof;
        }

        /// <summary>
        /// Create an input tracker
        /// </summary>
        /// <param name="config">MLInputConfiguration specifying desired configuration Pass NULL for default configuration</param>
        /// <param name="out_handle">A handle to the created input tracker Only valid if the return value is MLResult_Ok</param>
        /// <returns>
        /// MLResult_InvalidParam Input tracker was not created due to invalid out_handle
        /// MLResult_Ok Input tracker was created successfully
        /// MLResult_UnspecifiedFailure Input tracker was not created due to an unknown error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputCreate(in MlInput.MLInputConfiguration config, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Sets the callbacks for controller input events
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="controller_callbacks">Pointer to MLInputControllerCallbacks structure (can be NULL)</param>
        /// <param name="user_data">Pointer to user payload data; this will be the first argument
        /// passed to all the callback functions (can be NULL)</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to set the callback for controller input events due to an invalid handle
        /// MLResult_Ok Successfully set the callback for controller input events
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputSetControllerCallbacks(MlApi.MLHandle handle, in MlInput.MLInputControllerCallbacks controller_callbacks, IntPtr user_data);

        /// <summary>
        /// Return current state of all possible input controllers
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="out_state">Array, of at least size MLInput_MaxControllers, of
        /// MLInputControllerState structures that will be populated</param>
        /// <returns>
        /// MLResult_InvalidParam Fetching the controller state failed due to an invalid handle
        /// MLResult_Ok Successfully fetched the controller state
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputGetControllerState(MlApi.MLHandle handle, [MarshalAs(UnmanagedType.LPArray, SizeConst = 2)] MlInput.MLInputControllerState[] out_state);

        /// <summary>
        /// Starts a vibe feedback pattern on the specified controller
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="controller_id">ID of the input controller</param>
        /// <param name="pattern">Element of MLInputControllerFeedbackPatternVibe type specifying pattern to start</param>
        /// <param name="intensity">Element of MLInputControllerFeedbackIntensity type specifying intensity</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to start a vibe feedback pattern due to an invalid handle
        /// MLResult_Ok Successfully started a vibe feedback pattern on the specified controller
        /// MLResult_UnspecifiedFailure Failed to start a vibe feedback pattern due to an unknown error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputStartControllerFeedbackPatternVibe(MlApi.MLHandle handle, byte controller_id, MlInput.MLInputControllerFeedbackPatternVibe pattern, MlInput.MLInputControllerFeedbackIntensity intensity);

        /// <summary>
        /// Starts a LED feedback pattern on the specified controller
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="controller_id">ID of the input controller</param>
        /// <param name="pattern">Element of MLInputControllerFeedbackPatternLED type specifying pattern to start</param>
        /// <param name="color">Element of MLInputControllerFeedbackColorLED type specifying color</param>
        /// <param name="duration">Duration in milliseconds</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to start a LED feedback pattern due to an invalid handle
        /// MLResult_Ok Successfully started a LED feedback pattern on the specified controller
        /// MLResult_UnspecifiedFailure Failed to start a LED feedback pattern due to an unknown error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputStartControllerFeedbackPatternLED(MlApi.MLHandle handle, byte controller_id, MlInput.MLInputControllerFeedbackPatternLED pattern, MlInput.MLInputControllerFeedbackColorLED color, uint duration);

        /// <summary>
        /// Starts a LED feedback effect using the specified pattern on the specified controller
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="controller_id">ID of the input controller</param>
        /// <param name="effect">Element of MLInputControllerFeedbackEffectLED type specifying effect to start</param>
        /// <param name="speed">Element of MLInputControllerFeedbackEffectSpeedLED type specifying speed</param>
        /// <param name="pattern">Element of MLInputControllerFeedbackPatternLED type specifying pattern to use</param>
        /// <param name="color">Element of MLInputControllerFeedbackColorLED type specifying color</param>
        /// <param name="duration">Duration in milliseconds</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to start a LED feedback effect due to an invalid handle
        /// MLResult_Ok Successfully started a LED feedback effect using the specified pattern on the specified controller
        /// MLResult_UnspecifiedFailure Failed to start a LED feedback effect due to an unknown error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputStartControllerFeedbackPatternEffectLED(MlApi.MLHandle handle, byte controller_id, MlInput.MLInputControllerFeedbackEffectLED effect, MlInput.MLInputControllerFeedbackEffectSpeedLED speed, MlInput.MLInputControllerFeedbackPatternLED pattern, MlInput.MLInputControllerFeedbackColorLED color, uint duration);

        /// <summary>
        /// Sets the callbacks for keyboard input events
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="keyboard_callbacks">Pointer to MLInputKeyboardCallbacks structure (can be NULL)</param>
        /// <param name="user_data">Pointer to user payload data; this will be the first argument
        /// passed to all the callback functions (can be NULL)</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to set the callback for keyboard input events due to an invalid handle
        /// MLResult_Ok Successfully set the callback for keyboard input events
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputSetKeyboardCallbacks(MlApi.MLHandle handle, in MlInput.MLInputKeyboardCallbacks keyboard_callbacks, IntPtr user_data);

        /// <summary>
        /// Return current state of keyboard keys (down=true)
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="out_state">Pointer to MLInputKeyboardState structure that will receive data</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to fetch the keyboard state due to an invalid handle
        /// MLResult_Ok Successfully fetched the keyboard state
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputGetKeyboardState(MlApi.MLHandle handle, ref MlInput.MLInputKeyboardState out_state);

        /// <summary>
        /// Gets the device IDs of all connected devices
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="out_devices">Pointer to MLInputConnectedDevicesList structure that will be populated
        /// The app should call MLInputReleaseConnectedDevicesList to release the contents after use</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to get the IDs of all connected devices
        /// MLResult_Ok Successfully fetched the IDs of the connected devices
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @apilevel 5
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputGetConnectedDevices(MlApi.MLHandle handle, ref MlInput.MLInputConnectedDevicesList out_devices);

        /// <summary>
        /// Release the contents of MLInputConnectedDevicesList populated by MLInputGetConnectedDevices
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="devices">Pointer to MLInputConnectedDevicesList struct Its contents will be released</param>
        /// <returns>
        /// MLResult_Ok If operation was successful
        /// MLResult_InvalidParam Releasing the contents failed due to an invalid param
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @apilevel 5
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputReleaseConnectedDevicesList(MlApi.MLHandle handle, ref MlInput.MLInputConnectedDevicesList devices);

        /// <summary>
        /// Sets the callbacks for tablet device input events
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="touch_device_callbacks">Pointer to MLInputTabletDeviceCallbacks structure (can be NULL)</param>
        /// <param name="user_data">Pointer to user payload data (can be NULL)</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to set the callback for tablet device input events due to an invalid param
        /// MLResult_Ok Successfully set the callbacks for tablet device input events
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @apilevel 5
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputSetTabletDeviceCallbacks(MlApi.MLHandle handle, in MlInput.MLInputTabletDeviceCallbacks touch_device_callbacks, IntPtr user_data);

        /// <summary>
        /// Return a list of states of the tablet device
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="tablet_device_id">ID of the tablet device to fetch the states from</param>
        /// <param name="out_state">Pointer to MLInputTabletDeviceStatesList structure that will be populated
        /// The app should call MLInputReleaseTabletDeviceStates to release the contents after use</param>
        /// <returns>
        /// MLResult_Ok Successfully fetched the tablet device state
        /// MLResult_InvalidParam Fetching tablet device states failed due to an invalid param
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// This API will return all the states of tablet device since the last query upto a maximum of 20 states
        /// The memory used to store the list is maintained by the library User should call
        /// MLInputReleaseTabletDeviceStates to release it
        /// @apilevel 5
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputGetTabletDeviceStates(MlApi.MLHandle handle, byte tablet_device_id, ref MlInput.MLInputTabletDeviceStatesList out_state);

        /// <summary>
        /// Release the contents of MLInputTabletDeviceStatesList populated by MLInputGetTabletDeviceStates
        /// </summary>
        /// <param name="handle">Handle to the input tracker</param>
        /// <param name="tablet_device_states">Pointer to MLInputTabletDeviceStatesList structure Its contents will be released</param>
        /// <returns>
        /// MLResult_Ok If operation was successful
        /// MLResult_InvalidParam Releasing the contents failed due to an invalid param
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @apilevel 5
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputReleaseTabletDeviceStates(MlApi.MLHandle handle, ref MlInput.MLInputTabletDeviceStatesList tablet_device_states);

        /// <summary>
        /// Destroy an input tracker
        /// </summary>
        /// <param name="handle">MLHandle to the input tracker to destroy</param>
        /// <returns>
        /// MLResult_InvalidParam Failed to destroy the input tracker due to an invalid handle
        /// MLResult_Ok Successfully destroyed the input tracker
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_input", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLInputDestroy(MlApi.MLHandle handle);
    }
}

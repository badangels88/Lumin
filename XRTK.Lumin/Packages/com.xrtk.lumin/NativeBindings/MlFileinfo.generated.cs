//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlFileinfo
    {
        /// <summary>
        /// Opaque structure containing file information like mime type, fd, file name
        /// </summary>
        /// <remarks>
        /// The fields in this structure can be obtained by:
        /// File descriptor - Can be obtained by calling MLFileInfoGetFD
        /// File mime type  - Can be obtained by calling MLFileInfoGetMimeType
        /// File name       - Can be obtained by calling MLFileInfoGetFileName
        /// </remarks>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly struct MLFileInfo : IEquatable<MLFileInfo>
        {
            private readonly IntPtr _handle;

            public MLFileInfo(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(MLFileInfo other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is MLFileInfo other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(MLFileInfo left, MLFileInfo right) => left.Equals(right);

            public static bool operator !=(MLFileInfo left, MLFileInfo right) => !left.Equals(right);
        }

        /// <summary>
        /// This typedef can be used directly with POSIX APIs like open, close etc
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly struct MLFileDescriptor : IEquatable<MLFileDescriptor>
        {
            public MLFileDescriptor(int value) => this.Value = value;

            public readonly int Value;

            public bool Equals(MLFileDescriptor other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is MLFileDescriptor other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator int(MLFileDescriptor from) => from.Value;

            public static implicit operator MLFileDescriptor(int from) => new MLFileDescriptor(from);

            public static bool operator ==(MLFileDescriptor left, MLFileDescriptor right) => left.Equals(right);

            public static bool operator !=(MLFileDescriptor left, MLFileDescriptor right) => !left.Equals(right);
        }

        /// <summary>
        /// This API allocates an empty MLFileInfo structure
        /// </summary>
        /// <param name="out_file_info">Pointer to MLFileInfo pointer The caller should free the pointer by
        /// calling MLFileInfoRelease</param>
        /// <returns>
        /// MLResult_Ok on success
        /// MLResult_InvalidParam if input parameter is invalid
        /// MLResult_AllocFailed if memory allocation fails
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// priv none
        /// </returns>
        /// <remarks>
        /// The mime type, file name fields will be set to NULL and file descriptor
        /// will be set to -1
        /// </remarks>
        [DllImport("ml_lifecycle", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLFileInfoAllocateEmpty(out MlFileinfo.MLFileInfo out_file_info);

        /// <summary>
        /// This API retrieves the mime type of the given MLFileInfo
        /// </summary>
        /// <param name="file_info">Pointer to MLFileInfo struct pointer</param>
        /// <param name="out_mime_type">Address of pointer to mime type of the given MLFileInfo
        /// The caller should not free the pointer returned</param>
        /// <returns>
        /// MLResult_Ok on success
        /// MLResult_InvalidParam if input parameter is invalid
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// priv none
        /// </returns>
        /// <remarks>
        /// This returned mime type can be of the pattern 
        /// &lt;type
        /// /sub-type&gt;
        /// eg application/xml where "application" is type and "xml" is sub-type
        /// </remarks>
        [DllImport("ml_lifecycle", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLFileInfoGetMimeType(MlFileinfo.MLFileInfo file_info, out string out_mime_type);

        /// <summary>
        /// This API retrieves the file name associated with the given MLFileInfo
        /// </summary>
        /// <param name="file_info">Pointer to MLFileInfo struct pointer</param>
        /// <param name="out_file_name">Address of pointer to file name of the given MLFileInfo
        /// The caller should not free the pointer returned</param>
        /// <returns>
        /// MLResult_Ok on success
        /// MLResult_InvalidParam if input parameter is invalid
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// priv none
        /// </returns>
        /// <remarks>
        /// This is for information purposes only and cannot be used to access the file
        /// itself That can only be accessed via the file descriptor obtained from
        /// MLFileInfoGetFD
        /// </remarks>
        [DllImport("ml_lifecycle", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLFileInfoGetFileName(MlFileinfo.MLFileInfo file_info, out string out_file_name);

        /// <summary>
        /// This API retrieves the file descriptor of the given MLFileInfo
        /// </summary>
        /// <param name="file_info">Pointer to MLFileInfo struct pointer</param>
        /// <param name="out_fd">Pointer to variable that will hold the file descriptor of the given MLFileInfo</param>
        /// <returns>
        /// MLResult_Ok on success
        /// MLResult_InvalidParam if input parameter is invalid
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// priv none
        /// </returns>
        [DllImport("ml_lifecycle", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLFileInfoGetFD(MlFileinfo.MLFileInfo file_info, ref MlFileinfo.MLFileDescriptor out_fd);

        /// <summary>
        /// Sets the file descriptor for the given MLFileInfo structure
        /// </summary>
        /// <param name="file_info">MLFileInfo structure whose file descriptor field will be set</param>
        /// <param name="fd">file descriptor that will be set in MLFileInfo</param>
        /// <returns>
        /// MLResult_Ok on success
        /// MLResult_InvalidParam if input parameter is invalid
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// priv none
        /// </returns>
        /// <remarks>
        /// This makes a copy/dup of the file descriptor, so the caller has to
        /// close fd when no longer needed
        /// </remarks>
        [DllImport("ml_lifecycle", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLFileInfoSetFD(MlFileinfo.MLFileInfo file_info, int fd);

        /// <summary>
        /// Sets the file name for the given MLFileInfo structure
        /// </summary>
        /// <param name="file_info">MLFileInfo structure who's file name field will be set</param>
        /// <param name="file_name">file name associated with the fd that will be set in MLFileInfo</param>
        /// <returns>
        /// MLResult_Ok on success
        /// MLResult_InvalidParam if input parameter is invalid
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// priv none
        /// </returns>
        /// <remarks>
        /// The memory used to store the string will be released in MLFileInfoRelease
        /// </remarks>
        [DllImport("ml_lifecycle", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLFileInfoSetFileName(MlFileinfo.MLFileInfo file_info, [MarshalAs(UnmanagedType.LPStr)] string file_name);

        /// <summary>
        /// Sets the file mime type for the given MLFileInfo structure
        /// </summary>
        /// <param name="file_info">MLFileInfo structure who's mime type field will be set</param>
        /// <param name="mime_type">mime type of the file that will be set in MLFileInfo</param>
        /// <returns>
        /// MLResult_Ok on success
        /// MLResult_InvalidParam if input parameter is invalid
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// priv none
        /// </returns>
        /// <remarks>
        /// The memory used to store the string will be released in MLFileInfoRelease
        /// </remarks>
        [DllImport("ml_lifecycle", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLFileInfoSetMimeType(MlFileinfo.MLFileInfo file_info, [MarshalAs(UnmanagedType.LPStr)] string mime_type);

        /// <summary>
        /// Frees the pointer to MLFileInfo that is allocated by MLFileInfoAllocateEmpty
        /// </summary>
        /// <param name="file_info">pointer to MLFileInfo structure pointer that will be freed</param>
        /// <returns>
        /// MLResult_Ok on success
        /// MLResult_InvalidParam if input parameter is invalid
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// priv none
        /// </returns>
        /// <remarks>
        /// The memory used to store the file info and mime type strings will be released in
        /// MLFileInfoRelease The file descriptor stored in the MLFileInfo structure is also
        /// closed
        /// </remarks>
        [DllImport("ml_lifecycle", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLFileInfoRelease(out MlFileinfo.MLFileInfo file_info);
    }
}

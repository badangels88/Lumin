//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlDispatch
    {
        /// <summary>
        ///  Dispatch
        /// This interface lets an application query the platform to handle things
        /// that the app itself cannot or wants someone else to handle
        /// For example, if an application comes across a schema tag that it doesn't know
        /// what to do with, it can query the platform to see if some other application might
        /// This can be useful for handling http://, https:// or other custom Schema://
        /// &lt;arg1
        /// &gt;/
        /// &lt;arg2
        /// &gt;
        /// Apart from handling schema tags in URIs, this interface can also be used
        /// to query the platform to handle a type of file based on file-extension or mime-type
        /// </summary>
        /// <remarks>
        /// \
        /// {
        /// </remarks>
        public const int MLResultAPIPrefix_Dispatch = unchecked((int)0xBBE0 << 16);

        /// <summary>
        /// Return values for Dispatch API calls
        /// @apilevel 6
        /// </summary>
        public enum MLDispatchResult : int
        {
            /// <summary>
            /// Cannot start app
            /// </summary>
            MLDispatchResult_CannotStartApp = unchecked((int)MLResultAPIPrefix_Dispatch),

            /// <summary>
            /// Invalid packet
            /// </summary>
            MLDispatchResult_InvalidPacket,

            /// <summary>
            /// No app found
            /// </summary>
            MLDispatchResult_NoAppFound,

            /// <summary>
            /// App packet dialog failure
            /// </summary>
            MLDispatchResult_AppPickerDialogFailure,

            /// <summary>
            /// App packet dialog failure
            /// </summary>
            MLDispatchResult_InvalidSchema,

            /// <summary>
            /// Invalid url
            /// </summary>
            MLDispatchResult_InvalidUrl,

            /// <summary>
            /// Schema already has been registered
            /// </summary>
            MLDispatchResult_SchemaAlreadyRegistered,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLDispatchResult_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// MLDispatchPacket type can be used with this interface
        /// It can be used to pass a URI string or MLFileInfo objects
        /// to the platform
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly struct MLDispatchPacket : IEquatable<MLDispatchPacket>
        {
            private readonly IntPtr _handle;

            public MLDispatchPacket(IntPtr handle) => _handle = handle;

            public IntPtr Handle => _handle;

            public bool Equals(MLDispatchPacket other) => _handle.Equals(other._handle);

            public override bool Equals(object obj) => obj is MLDispatchPacket other && Equals(other);

            public override int GetHashCode() => _handle.GetHashCode();

            public override string ToString() => "0x" + (IntPtr.Size == 8 ? _handle.ToString("X16") : _handle.ToString("X8"));

            public static bool operator ==(MLDispatchPacket left, MLDispatchPacket right) => left.Equals(right);

            public static bool operator !=(MLDispatchPacket left, MLDispatchPacket right) => !left.Equals(right);
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void ml_dispatch_oauth_schema_handler([MarshalAs(UnmanagedType.LPStr)] string response);

        /// <summary>
        /// Create empty dispatch packet
        /// </summary>
        /// <param name="out_packet">A pointer to MLDispatchPacket structure on success and NULL on failure</param>
        /// <returns>
        /// MLResult_AllocFailed If failed to allocate dispatch packet
        /// MLResult_Ok If dispatch packet was allocated successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// The MLFileInfo array in the MLDispatchPacket returned by this function
        /// will be NULL as will the uri In order to allocate memory for these
        /// members, caller will have to explicitly call MLDispatchAllocateFileInfoList
        /// and MLDispatchAllocateUri respectively
        /// The caller will need to free this structure by calling MLDispatchReleasePacket
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchAllocateEmptyPacket(out MlDispatch.MLDispatchPacket out_packet);

        /// <summary>
        /// Release the MLDispatchPacket that is allocated by MLDispatchAllocateEmptyPacket
        /// and all its resources The pointer to the MLDispatchPacket struct will point to NULL after this call
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket struct pointer</param>
        /// <param name="release_members">If @c true, function will attempt to release/free
        /// MLFileInfo array and uri members from the MLDispatchPacket</param>
        /// <param name="close_fds">If @c true, function will attempt to close the fds in MLFileInfo,
        /// If @c false, caller will have to close fds</param>
        /// <returns>
        /// MLResult_InvalidParam If a function parameter is not valid
        /// MLResult_Ok If memory allocated to dispatch packet is released successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchReleasePacket(out MlDispatch.MLDispatchPacket packet, [MarshalAs(UnmanagedType.U1)] bool release_members, [MarshalAs(UnmanagedType.U1)] bool close_fds);

        /// <summary>
        /// Allocate an empty MLFileInfo array in the MLDispatchPacket for given length
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket whose MLFileInfo* member will be
        /// allocated file_info_list_length entries</param>
        /// <param name="file_info_list_length">Maximum length of the file info array to be allocated</param>
        /// <returns>
        /// MLResult_AllocFailed If allocation of MLFileInfo array failed
        /// MLResult_InvalidParam If a function parameter is not valid
        /// MLResult_Ok If MLFileInfo array is successfully allocated file_info_list_length entries
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// The caller can release/free by calling MLDispatchReleaseFileInfo or by calling
        /// MLDispatchReleasePacket
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchAllocateFileInfoList(MlDispatch.MLDispatchPacket packet, ulong file_info_list_length);

        /// <summary>
        /// This API retrieves length of the MLFileInfo array in the given MLDispatchPacket
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket whose MLFileInfo* member's list length
        /// is calculated and stored in out_file_info_list_length</param>
        /// <param name="out_file_info_list_length">length of MLFileInfo array</param>
        /// <returns>
        /// MLResult_InvalidParam If a function parameter is not valid
        /// MLResult_Ok If operation is successful
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// This function can return length of 0 which implies there is no file info
        /// available
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchGetFileInfoListLength(MlDispatch.MLDispatchPacket packet, ref ulong out_file_info_list_length);

        /// <summary>
        /// Get the MLFileInfo at the given index
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket whose MLFileInfo array for given index will be returned</param>
        /// <param name="index">Index of the MLFileInfo array</param>
        /// <param name="out_file_info">Pointer to MLFileInfo* in packet at index</param>
        /// <returns>
        /// MLResult_InvalidParam If a function parameter is not valid
        /// MLResult_Ok if the MLFileInfo object at the parameter index can be retrieved successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// The MLFileInfo array should have been allocated by calling MLDispatchAllocateFileInfoList
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchGetFileInfoByIndex(MlDispatch.MLDispatchPacket packet, long index, out MlFileinfo.MLFileInfo out_file_info);

        /// <summary>
        /// Populate MLFileInfo array in the MLDispatchPacket for current index
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket whose MLFileInfo* member will be populated</param>
        /// <param name="finfo">MLFileInfo structure that will be added to the MLDispatchPacket</param>
        /// <returns>
        /// MLResult_AllocFailed If failed to allocate memory for one of the fields in MLFileInfo
        /// or there are no available slots in the MLFileInfo array in the packet
        /// MLResult_InvalidParam If a function parameter is not valid
        /// MLResult_Ok If parameter finfo was successfully added to MLFileInfo array in the packet
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// The caller will have to call MLDispatchAllocateFileInfoList before calling this
        /// function After obtaining the length of the list through MLDispatchGetFileInfoListLength,
        /// the caller should get each MLFileInfo structures in the array through
        /// MLDispatchGetFileInfoByIndex After setting the fields of MLFileInfo using mutator
        /// functions, this function should be called to add the MLFileInfo just set to the
        /// dispatch packet
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchAddFileInfo(MlDispatch.MLDispatchPacket packet, MlFileinfo.MLFileInfo finfo);

        /// <summary>
        /// Release the pointer to MLFileInfo array that is allocated by MLDispatchAllocateFileInfoList
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket</param>
        /// <param name="close_fds">If @c true, function will attempt to close the fds in MLFileInfo,
        /// if @c false, caller will have to close fds</param>
        /// <returns>
        /// MLResult_InvalidParam If a function parameter is not valid
        /// MLResult_Ok If memory allocated to MLFileInfo array was released successfully
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// The caller will have to call MLDispatchAllocateFileInfoList before calling this
        /// function The MLFileInfo pointer in MLDispatchPacket will point to NULL after
        /// this call
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchReleaseFileInfoList(MlDispatch.MLDispatchPacket packet, [MarshalAs(UnmanagedType.U1)] bool close_fds);

        /// <summary>
        /// Allocate and assign URI in the MLDispatchPacket
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket whose uri member will be allocated and populated</param>
        /// <param name="uri">Value assigned to MLDispatchPacket's uri member</param>
        /// <returns>
        /// MLResult_AllocFailed If failed to allocate uri
        /// MLResult_InvalidParam If a function parameter is not valid
        /// MLResult_Ok If operation is succesfful
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// The caller can release/free by calling MLDispatchReleaseUri or by calling
        /// MLDispatchReleasePacket
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchSetUri(MlDispatch.MLDispatchPacket packet, [MarshalAs(UnmanagedType.LPStr)] string uri);

        /// <summary>
        /// Release uri that is allocated by MLDispatchAllocateUri
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket struct pointer</param>
        /// <returns>
        /// MLResult_InvalidParam If a function parameter is not valid
        /// MLResult_Ok If operation is successful
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// </returns>
        /// <remarks>
        /// The caller will have to call MLDispatchSetUri before calling this
        /// function The char pointer uri in MLDispatchPacket will point to NULL after
        /// this call
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchReleaseUri(MlDispatch.MLDispatchPacket packet);

        /// <summary>
        /// Try to open the application that supports a given mime type or schema type
        /// </summary>
        /// <param name="packet">Pointer to MLDispatchPacket structure</param>
        /// <returns>
        /// MLResult_Ok If an application was found that can open a given mime or schema type,
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// MLDispatchResult Dispatch specific error occurred
        /// </returns>
        /// <remarks>
        /// If the caller does not specify a mime-type or schema type in the dispatch packet,
        /// dispatch service will try to open an application which supports the file extension
        /// specified in the file name
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchTryOpenApplication(MlDispatch.MLDispatchPacket packet);

        /// <summary>
        /// Register a unique schema for OAuth redirect handler
        /// </summary>
        /// <param name="schema">A unique string that will match the redirect uri schema</param>
        /// <param name="handler">The callback handler when this schema redirect uri has been invoked</param>
        /// <returns>
        /// MLResult_Ok If the new schema has been registered correctly
        /// MLResult_PrivilegeDenied If SecureBrowserWindow privilege is denied
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// MLDispatchResult_SchemaAlreadyRegistered Schema already is registered
        /// MLDispatchResult Dispatch specific error occurred
        /// </returns>
        /// <remarks>
        /// The caller need to ensure that the schema is unique If the schema
        /// is already registered the function will return an error The handler
        /// will be called once the authorization procedure has been completed
        /// The caller should register two schema callbacks The first will be for
        /// authorization redirect and the second schema will in case the user cancels
        /// the authentication
        /// @apilevel 6
        /// @priv SecureBrowserWindow
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchOAuthRegisterSchema([MarshalAs(UnmanagedType.LPStr)] string schema, MlDispatch.ml_dispatch_oauth_schema_handler handler);

        /// <summary>
        /// Unregister a unique schema for OAuth redirect handler
        /// </summary>
        /// <param name="schema">A unique string that will match the redirect uri schema</param>
        /// <returns>
        /// MLResult_Ok If the new schema has been registered correctly
        /// MLResult_PrivilegeDenied If SecureBrowserWindow privilege is denied
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// MLDispatchResult Dispatch specific error occurred
        /// </returns>
        /// <remarks>
        /// @apilevel 6
        /// @priv SecureBrowserWindow
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchOAuthUnregisterSchema([MarshalAs(UnmanagedType.LPStr)] string schema);

        /// <summary>
        /// Open a secure browser window to perfrom an oauth authentication
        /// </summary>
        /// <param name="url">The oauth url to navigate to</param>
        /// <param name="cancel_uri">The cancel uri called by the browser when users cancels the window</param>
        /// <returns>
        /// MLResult_Ok If the browser oauth window opened correctly
        /// MLResult_PrivilegeDenied If SecureBrowserWindow privilege is denied
        /// MLResult_UnspecifiedFailure The operation failed with an unspecified error
        /// MLDispatchResult Dispatch specific error occurred
        /// </returns>
        /// <remarks>
        /// Will open a special browser window that will be laz head locked to
        /// the user's head movement The browser window will close once the
        /// authentication procedure has been completed
        /// @apilevel 6
        /// @priv SecureBrowserWindow
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDispatchOAuthOpenWindow([MarshalAs(UnmanagedType.LPStr)] string url, [MarshalAs(UnmanagedType.LPStr)] string cancel_uri);

        /// <summary>
        /// Returns an ASCII string for MLDispatchResult and MLResultGlobal codes
        /// </summary>
        /// <param name="result_code">The input MLResult enum from MLDispatch functions</param>
        /// <returns>
        /// ASCII string containing readable version of result code
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_dispatch", CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        public static extern string MLDispatchGetResultString(MlApi.MLResult result_code);
    }
}

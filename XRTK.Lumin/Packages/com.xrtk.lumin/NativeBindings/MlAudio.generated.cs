//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlAudio
    {
        /// <summary>
        /// Possible playback states for sounds and inputs
        /// </summary>
        public enum MLAudioState : int
        {
            /// <summary>
            /// Stopped, can be started
            /// </summary>
            MLAudioState_Stopped,

            /// <summary>
            /// Playing, can be stopped or paused
            /// </summary>
            MLAudioState_Playing,

            /// <summary>
            /// Paused, can be resumed or re-started
            /// </summary>
            MLAudioState_Paused,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLAudioState_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Possible audio events for sounds and inputs
        /// </summary>
        public enum MLAudioEvent : int
        {
            /// <summary>
            /// Sound at end and is stopping
            /// </summary>
            MLAudioEvent_End,

            /// <summary>
            /// Sound at end and is looping
            /// </summary>
            MLAudioEvent_Loop,

            /// <summary>
            /// Sound or input muted by policy manager
            /// </summary>
            MLAudioEvent_MutedBySystem,

            /// <summary>
            /// Sound or input unmuted by policy manager
            /// </summary>
            MLAudioEvent_UnmutedBySystem,

            /// <summary>
            /// Sound ducked by policy manager
            /// </summary>
            MLAudioEvent_DuckedBySystem,

            /// <summary>
            /// Sound unducked by policy manager
            /// </summary>
            MLAudioEvent_UnduckedBySystem,

            /// <summary>
            /// Resource used by sound has been destroyed
            /// </summary>
            MLAudioEvent_ResourceDestroyed,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLAudioEvent_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// The currently active output device
        /// </summary>
        public enum MLAudioOutputDevice : int
        {
            /// <summary>
            /// Built-in speakers in the wearable
            /// </summary>
            MLAudioOutputDevice_Wearable,

            /// <summary>
            /// 35mm jack on the beltpack
            /// </summary>
            MLAudioOutputDevice_AnalogJack,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLAudioOutputDevice_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Possible sample formats for input and output streams
        /// </summary>
        public enum MLAudioSampleFormat : int
        {
            /// <summary>
            /// Samples are integer
            /// </summary>
            MLAudioSampleFormat_Int,

            /// <summary>
            /// Samples are float - NOT IMPLEMENTED
            /// </summary>
            MLAudioSampleFormat_Float,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLAudioSampleFormat_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        public const int MLResultAPIPrefix_Audio = unchecked((int)0x9e11 << 16);

        /// <summary>
        /// Return values for Audio Service API calls
        /// @apilevel 4
        /// </summary>
        public enum MLAudioResult : int
        {
            /// <summary>
            /// Function not implemented
            /// </summary>
            MLAudioResult_NotImplemented = unchecked((int)MLResultAPIPrefix_Audio),

            /// <summary>
            /// Not a valid MLHandle for a sound or input
            /// </summary>
            MLAudioResult_HandleNotFound,

            /// <summary>
            /// Sample rate not supported
            /// </summary>
            MLAudioResult_InvalidSampleRate,

            /// <summary>
            /// Bits per sample not supported
            /// </summary>
            MLAudioResult_InvalidBitsPerSample,

            /// <summary>
            /// Valid bits per sample not supported
            /// </summary>
            MLAudioResult_InvalidValidBits,

            /// <summary>
            /// Sample format not supported
            /// </summary>
            MLAudioResult_InvalidSampleFormat,

            /// <summary>
            /// Channel count not supported
            /// </summary>
            MLAudioResult_InvalidChannelCount,

            /// <summary>
            /// Buffer size too small
            /// </summary>
            MLAudioResult_InvalidBufferSize,

            /// <summary>
            /// Buffer not ready for read or write
            /// </summary>
            MLAudioResult_BufferNotReady,

            /// <summary>
            /// Specified file not found
            /// </summary>
            MLAudioResult_FileNotFound,

            /// <summary>
            /// Specified file has unsupported format
            /// </summary>
            MLAudioResult_FileNotRecognized,

            /// <summary>
            /// Specified resource is not on the list
            /// </summary>
            MLAudioResult_ResourceNotFound,

            /// <summary>
            /// Data was unloaded or file was closed
            /// </summary>
            MLAudioResult_ResourceDiscarded,

            /// <summary>
            /// Requested operation not possible for given item
            /// </summary>
            MLAudioResult_OperationUnavailable,

            /// <summary>
            /// Internal configuration problem was detected
            /// </summary>
            MLAudioResult_InternalConfigError,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLAudioResult_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        /// <summary>
        /// Properties specifying the distance response of a spatial sound
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLAudioSpatialSoundDistanceProperties
        {
            /// <summary>
            /// Distance where sound is at full volume
            /// </summary>
            public float min_distance;

            /// <summary>
            /// Distance beyond which sound gets no quieter
            /// </summary>
            public float max_distance;

            /// <summary>
            /// Modification to real-world distance response
            /// </summary>
            public float rolloff_factor;
        }

        /// <summary>
        /// Properties specifying the directivity of a spatial sound
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLAudioSpatialSoundRadiationProperties
        {
            /// <summary>
            /// Inner cone angle (0-360); radiation unaffected
            /// </summary>
            public float inner_angle;

            /// <summary>
            /// Outer cone angle (0-360); directivity at maximum
            /// </summary>
            public float outer_angle;

            /// <summary>
            /// Volume scale (0-1) beyond outer cone for all freqs
            /// </summary>
            public float outer_gain;

            /// <summary>
            /// Volume scale (0-1) beyond outer cone for low freqs
            /// </summary>
            public float outer_gain_lf;

            /// <summary>
            /// Volume scale (0-1) beyond outer cone for mid freqs
            /// </summary>
            public float outer_gain_mf;

            /// <summary>
            /// Volume scale (0-1) beyond outer cone for high freqs
            /// </summary>
            public float outer_gain_hf;
        }

        /// <summary>
        /// Properties specifying send levels for a spatial sound
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLAudioSpatialSoundSendLevels
        {
            /// <summary>
            /// Volume scale (0-1) for all freqs
            /// </summary>
            public float gain;

            /// <summary>
            /// Volume scale (0-1) for low freqs
            /// </summary>
            public float gain_lf;

            /// <summary>
            /// Volume scale (0-1) for mid freqs
            /// </summary>
            public float gain_mf;

            /// <summary>
            /// Volume scale (0-1) for high freqs
            /// </summary>
            public float gain_hf;
        }

        /// <summary>
        /// Properties specifying room acoustics
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLAudioSpatialSoundRoomProperties
        {
            /// <summary>
            /// Volume scale (0-1) for all room sound
            /// </summary>
            public float gain;

            /// <summary>
            /// Pre-delay (secs) for early reflections
            /// </summary>
            public float reflections_delay;

            /// <summary>
            /// Volume scale (0-8) for early reflections
            /// </summary>
            public float reflections_gain;

            /// <summary>
            /// Additional delay (secs) for late reverberation
            /// </summary>
            public float reverb_delay;

            /// <summary>
            /// Volume scale (0-8) for late reverberation
            /// </summary>
            public float reverb_gain;

            /// <summary>
            /// Decay time (secs) for late reverberation
            /// </summary>
            public float reverb_decay_time;

            /// <summary>
            /// Relative decay time for low freq reverb
            /// </summary>
            public float reverb_decay_time_lf_ratio;

            /// <summary>
            /// Relative decay time for high freq reverb
            /// </summary>
            public float reverb_decay_time_hf_ratio;
        }

        /// <summary>
        /// Specification of lf, mf and hf frequencies used throughout
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLAudioSpatialSoundControlFrequencies
        {
            /// <summary>
            /// Frequency (Hz) for low freq control
            /// </summary>
            public float control_lf;

            /// <summary>
            /// Frequency (Hz) for mid freq control
            /// </summary>
            public float control_mf;

            /// <summary>
            /// Frequency (Hz) for high freq control
            /// </summary>
            public float control_hf;
        }

        /// <summary>
        /// Buffer format settings for input and output streams
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLAudioBufferFormat
        {
            /// <summary>
            /// Number of channels
            /// </summary>
            public uint channel_count;

            /// <summary>
            /// Sample rate
            /// </summary>
            public uint samples_per_second;

            /// <summary>
            /// Number of bits per sample
            /// </summary>
            public uint bits_per_sample;

            /// <summary>
            /// Number of bits used per sample
            /// </summary>
            public uint valid_bits_per_sample;

            /// <summary>
            /// Integer or float (float not implemented)
            /// </summary>
            public MlAudio.MLAudioSampleFormat sample_format;

            /// <summary>
            /// Reserved for future use
            /// </summary>
            public uint reserved;
        }

        /// <summary>
        /// An audio buffer for passing data from input streams or to output streams
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLAudioBuffer
        {
            /// <summary>
            /// Pointer to audio data
            /// </summary>
            public IntPtr ptr;

            /// <summary>
            /// Size of audio data
            /// </summary>
            public uint size;
        }

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void MLAudioEventCallback(MlApi.MLHandle handle, MlAudio.MLAudioEvent @event, IntPtr callback_context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void MLAudioBufferCallback(MlApi.MLHandle handle, IntPtr callback_context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void MLAudioResourceDiscardedCallback(MlApi.MLHandle resource, IntPtr callback_context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void MLAudioMasterVolumeChangedCallback(float new_volume, IntPtr callback_context);

        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void MLAudioMicMuteCallback([MarshalAs(UnmanagedType.U1)] bool is_muted, IntPtr callback_context);

        /// <summary>
        /// Returns an ASCII string for each result code
        /// </summary>
        /// <param name="result_code">MLResult to select the result code</param>
        /// <returns>
        /// ASCII string containing readable version of result code
        /// </returns>
        /// <remarks>
        /// This call returns strings for all of the MLResult and
        /// MLAudioResult codes
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.LPStr)]
        public static extern string MLAudioGetResultString(MlApi.MLResult result_code);

        /// <summary>
        /// Creates a new audio resource that references a loaded audio file
        /// </summary>
        /// <param name="file">file descriptor specifying the file to load</param>
        /// <param name="dynamic_decode">not currently implemented</param>
        /// <param name="callback">MLAudioResourceDiscardedCallback function pointer</param>
        /// <param name="callback_context">generic data pointer passed back to callback</param>
        /// <param name="out_resource">MLHandle used in subsequent calls for this resource</param>
        /// <returns>
        /// MLResult_AllocFailed If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If resource creation was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_FileNotRecognized File not recognized
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_InvalidBitsPerSample Invalid bits per sample
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Creates a new audio resource that references the audio file specified by the
        /// 'file' argument, which it tries to load during resource creation An optional
        /// MLAudioResourceDiscardedCallback will inform the client if the data later gets
        /// discarded due to memory limits (or if it fails to load during creation) After creation
        /// the resource can be played by passing its id to MLAudioCreateSoundWithLoadedResource
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateLoadedResource(int file, [MarshalAs(UnmanagedType.U1)] bool dynamic_decode, MlAudio.MLAudioResourceDiscardedCallback callback, IntPtr callback_context, ref MlApi.MLHandle out_resource);

        /// <summary>
        /// Creates a new audio resource that references a streamed audio file
        /// </summary>
        /// <param name="file">File descriptor specifying the file to load</param>
        /// <param name="callback">MLAudioResourceDiscardedCallback Function pointer</param>
        /// <param name="callback_context">Generic data pointer passed back to callback</param>
        /// <param name="out_resource">MLHandle used in subsequent calls for this resource</param>
        /// <returns>
        /// MLResult_AllocFailed If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If resource creation was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Creates a new audio resource that references the audio file specified by the 'file'
        /// argument An optional MLAudioResourceDiscardedCallback will inform the client if the
        /// file's file descriptor later gets discarded due to file descriptor limits (or if a file
        /// descriptor cannot be generated during resource creation) After creation the
        /// resource can be played by passing its id to MLAudioCreateSoundWithStreamedResource
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateStreamedResource(int file, MlAudio.MLAudioResourceDiscardedCallback callback, IntPtr callback_context, ref MlApi.MLHandle out_resource);

        /// <summary>
        /// Checks whether an audio resource has been discarded due to memory limits
        /// </summary>
        /// <param name="resource">MLHandle used to identify the resource</param>
        /// <param name="out_is_ready">Indicates whether the resource is ready or not</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If resource checking was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// This call can be used instead of the MLAudioResourceDiscardedCallback to determine whether
        /// an audio resource has been discarded Resources that are not being referenced by a sound
        /// will be discarded before resources that are being referenced by a sound Resources that
        /// are being played by a sound will not be discarded MLAudioCheckResource can be called
        /// just before the resource is needed, or at some other appropriate time for accessing data
        /// However it should not be called constantly on a polling basis to instantly refresh
        /// resources that get discarded, since that would defeat the purpose of the memory limit
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCheckResource(MlApi.MLHandle resource, ref bool out_is_ready);

        /// <summary>
        /// Refreshes an audio resource whose data was discarded due to memory limits
        /// </summary>
        /// <param name="resource">MLHandle used to identify the resource</param>
        /// <param name="file">File descriptor specifying the audio data to refresh</param>
        /// <returns>
        /// MLResult_AllocFailed If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If resource refreshing was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_FileNotRecognized File not recognized
        /// MLAudioResult_InternalConfigError Internal Config error
        /// MLAudioResult_InvalidBitsPerSample Invalid bits per sample
        /// MLAudioResult_InvalidBufferSize Invalid buffer size
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleFormat Invalid sample format
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_InvalidValidBits Invalid valid bits
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// This call allows the client to 'refresh' a resource whose data has been discarded This
        /// should be done just prior to the next time the data is needed, or some other convenient
        /// time when data access is appropriate, but not right after the data is discarded, as that
        /// would defeat the purpose of the memory limit
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioRefreshResource(MlApi.MLHandle resource, int file);

        /// <summary>
        /// Destroys a previously created audio resource If there are sounds that
        /// are currently playing the resource, they will be stopped, and an event callback
        /// will be issued for MLAudioEvent_ResourceDestroyed
        /// </summary>
        /// <param name="resource">MLHandle used to identify the resource</param>
        /// <returns>
        /// MLResult_Ok If resource destruction was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioDestroyResource(MlApi.MLHandle resource);

        /// <summary>
        /// Creates a new sound output that plays a loaded audio resource
        /// </summary>
        /// <param name="resource">MLHandle specifying the resource to play</param>
        /// <param name="auto_destroy">If true, the sound output is destroyed when done playing</param>
        /// <param name="out_handle">MLHandle used in subsequent calls for this sound output</param>
        /// <returns>
        /// MLResult_AllocFailed If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If sound creation was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_FileNotRecognized File not recognized
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_InvalidBitsPerSample Invalid bits per sample
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// Creates a sound output to play a loaded audio file referenced as a resource
        /// Loaded resources are created and loaded by calling MLAudioCreateLoadedResource
        /// After sound creation the sound can be started by calling MLAudioStartSound Supported
        /// file formats are all file types supported by the Multimedia Service, mono or stereo,
        /// sampled with a frequency in the range from 16 kHz - 48 kHz, and represented as
        /// 16-bit integers
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateSoundWithLoadedResource(MlApi.MLHandle resource, [MarshalAs(UnmanagedType.U1)] bool auto_destroy, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Creates a new sound output that plays a streamed audio resource
        /// </summary>
        /// <param name="resource">MLHandle specifying the resource to play</param>
        /// <param name="auto_destroy">If true, the sound output is destroyed when done playing</param>
        /// <param name="out_handle">MLHandle used in subsequent calls for this sound output</param>
        /// <returns>
        /// MLResult_AllocFailed Alloc If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If sound creation was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_InvalidBufferSize Invalid buffer size
        /// MLAudioResult_ResourceDiscarded Resource discarded
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// Creates a sound output to play a streamed audio file referenced as a resource
        /// Streamed resources are created by calling MLAudioCreateStreamedResource After sound
        /// creation the sound can be started by calling MLAudioStartSound  Supported file formats
        /// are all file types supported by the Multimedia Service, mono or stereo, sampled
        /// with a frequency in the range from 16 kHz - 48 kHz, and represented as 16-bit
        /// integers
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateSoundWithStreamedResource(MlApi.MLHandle resource, [MarshalAs(UnmanagedType.U1)] bool auto_destroy, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Creates a new sound output that plays a loaded file
        /// </summary>
        /// <param name="file">File descriptor specifying the file to play</param>
        /// <param name="auto_destroy">If true, the sound output is destroyed when done playing</param>
        /// <param name="dynamic_decode">Not currently implemented</param>
        /// <param name="out_handle">MLHandle used in subsequent calls for this sound output</param>
        /// <returns>
        /// MLResult_AllocFailed If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If sound creation was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_FileNotRecognized File not recognized
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_InvalidBitsPerSample Invalid bits per sample
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_InvalidValidBits Invalid valid bits
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// Creates a sound output and loads the audio file specified by the 'file'
        /// argument into memory After creation the sound can be started by calling
        /// MLAudioStartSound Supported file formats are all file types supported by
        /// the Multimedia Service, mono or stereo, sampled with a frequency in the range
        /// from 16 kHz - 48 kHz, and represented as 16-bit integers
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateSoundWithLoadedFile(int file, [MarshalAs(UnmanagedType.U1)] bool auto_destroy, [MarshalAs(UnmanagedType.U1)] bool dynamic_decode, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Creates a new sound output that plays a streamed file
        /// </summary>
        /// <param name="file">File descriptor specifying the file to play</param>
        /// <param name="auto_destroy">If true, the sound output is destroyed when done playing</param>
        /// <param name="out_handle">MLHandle used in subsequent calls for this sound output</param>
        /// <returns>
        /// MLResult_AllocFailed If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If sound creation was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_FileNotFound File not found
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_ResourceDiscarded Resource discarded
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// Creates a sound output and prepares to stream the audio file specified by the
        /// 'file' argument After creation the sound can be started by calling
        /// MLAudioStartSound Supported file formats are all file types supported by the
        /// Multimedia Service, mono or stereo, sampled with a frequency in the range from
        /// 16 kHz - 48 kHz, and represented as 16-bit integers
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateSoundWithStreamedFile(int file, [MarshalAs(UnmanagedType.U1)] bool auto_destroy, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Creates a new sound output that plays a buffered audio stream
        /// </summary>
        /// <param name="format">MLAudioBufferFormat specifying the audio format of the stream</param>
        /// <param name="buffer_size">Requested size in bytes for each of the two stream buffers</param>
        /// <param name="callback">MLAudioBufferCallback function pointer</param>
        /// <param name="callback_context">Generic data pointer passed back to callback</param>
        /// <param name="out_handle">MLHandle used in subsequent calls for this sound output</param>
        /// <returns>
        /// MLResult_AllocFailed If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If sound creation was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_InvalidBitsPerSample Invalid bits per sample
        /// MLAudioResult_InvalidBufferSize Invalid buffer size
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleFormat Invalid sample format
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_InvalidValidBits Invalid valid bits
        /// </returns>
        /// <remarks>
        /// Creates a sound output and allocates a double-buffer for streaming
        /// audio data into it To stream  data into the buffers call
        /// MLAudioGetOutputStreamBuffer to get an empty buffer, then write the
        /// data into the buffer, then call MLAudioReleaseOutputStreamBuffer to
        /// indicate that the buffer is ready to play This can be done either on
        /// a polling basis or within a callback set via the 'callback' argument The
        /// 'format' argument specifies the format of which the following are supported:
        /// mono or stereo, 16 bit integer, a sampling rate in the range of 16k - 48k
        /// The 'buffer_size' argument will use the recommended size if 0 is passed in
        /// After creation, one or both buffers can optionally be pre-filled, and the
        /// sound can be started by calling MLAudioStartSound
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateSoundWithOutputStream(in MlAudio.MLAudioBufferFormat format, uint buffer_size, MlAudio.MLAudioBufferCallback callback, IntPtr callback_context, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Destroys a previously created sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <returns>
        /// MLResult_Ok If sound destruction was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioDestroySound(MlApi.MLHandle handle);

        /// <summary>
        /// Starts playback for a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <returns>
        /// MLResult_Ok if starting was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_ResourceDiscarded Resource discarded
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// When starting playback for a file (loaded, streamed,
        /// system sound), playback starts at the beginning of the
        /// file (even after a pause) When starting playback for an
        /// output stream, the "frames played" counter gets reset
        /// to zero (and if the output stream was previously paused
        /// the streaming buffers get reset as well)
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioStartSound(MlApi.MLHandle handle);

        /// <summary>
        /// Stops playback for a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <returns>
        /// MLResult_Ok If stopping was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_ResourceNotFound Resource not found
        /// </returns>
        /// <remarks>
        /// Stops playback for a sound output that's playing or paused
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioStopSound(MlApi.MLHandle handle);

        /// <summary>
        /// Pauses playback for a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <returns>
        /// MLResult_Ok If pausing was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// Pauses playback for a sound output that's playing If the
        /// sound output is not playing, the pause will fail
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioPauseSound(MlApi.MLHandle handle);

        /// <summary>
        /// Resumes playback for a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <returns>
        /// MLResult_Ok If resuming was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// Resumes playback for a sound output that's paused If the
        /// sound output is not paused, the resume will fail
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioResumeSound(MlApi.MLHandle handle);

        /// <summary>
        /// Indicates the play state of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_state">indicates the current play state</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The MLAudioState indicates whether the sound output is
        /// stopped, playing or paused
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSoundState(MlApi.MLHandle handle, ref MlAudio.MLAudioState out_state);

        /// <summary>
        /// Returns the audio format of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_format">MLAudioBufferFormat struct containing the format info</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// The returned information includes the channel count, sample
        /// rate and bit depth of the sound's audio data For Streamed Files,
        /// the format is not available until about 100+ milliseconds after
        /// playback of the Streamed File is started
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSoundFormat(MlApi.MLHandle handle, ref MlAudio.MLAudioBufferFormat out_format);

        /// <summary>
        /// Registers a callback for events on a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="callback">MLAudioEventCallback function pointer</param>
        /// <param name="callback_context">Generic data pointer passed back to callback</param>
        /// <returns>
        /// MLResult_AllocFailed If memory allocation fails
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Events that can result in a callback being called include:
        /// stopping at the end of a file; looping at the end of a file;
        /// a sound output having its volume lowered or restored by the
        /// audio policy manager; a sound output being muted or unmuted
        /// by the audio policy manager The 'callback_context' argument
        /// is passed back to the callback as its first argument The
        /// particular event type (MLAudioEvent) that caused the callback
        /// is passed to the callback as its second argument
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSoundEventCallback(MlApi.MLHandle handle, MlAudio.MLAudioEventCallback callback, IntPtr callback_context);

        /// <summary>
        /// Enables/disables 3D audio processing for a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="is_enabled">Determines whether 3D processing is on or off</param>
        /// <returns>
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The 3D audio processing for a sound output can be turned on
        /// or off by this function (default is off) When 3D processing
        /// is enabled, the 3D position should be set by calling
        /// MLAudioSetSpatialSoundPosition When 3D processing is
        /// disabled, stereo sounds will play their left and right
        /// channels directly to the left and right speakers or
        /// earphones, and mono sounds will be panned center
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundEnable(MlApi.MLHandle handle, [MarshalAs(UnmanagedType.U1)] bool is_enabled);

        /// <summary>
        /// Indicates whether 3D audio processing is enabled for a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_is_enabled">Indicates whether 3D processing is on or off</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundEnable(MlApi.MLHandle handle, ref bool out_is_enabled);

        /// <summary>
        /// Sets the 3D position for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose position is being set</param>
        /// <param name="position">MLVec3f struct to set the position</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// When 3D audio processing is enabled for a sound output (see
        /// MLAudioSetSpatialSoundEnable) this funtions sets the
        /// perceived position within the user's environment Multi-channel
        /// sounds require the 3D position to be set individually for each
        /// channel by calling this function once for each channel For mono
        /// sounds use channel = 0 For stereo sounds use channel = 0 for
        /// left and channel = 1 for right Positive x is right Positive y
        /// is up Positive z is back
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundPosition(MlApi.MLHandle handle, uint channel, in MlTypes.MLVec3f position);

        /// <summary>
        /// Returns the 3D position for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose position is being read</param>
        /// <param name="out_position">MLVec3f struct to return the position</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Multi-channel sounds require the 3D position to be read individually
        /// for each channel by calling this function once for each channel For
        /// mono sounds use channel = 0 For stereo sounds use channel = 0
        /// for left and channel = 1 for right Positive x is right Positive y
        /// is up Positive z is back
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundPosition(MlApi.MLHandle handle, uint channel, ref MlTypes.MLVec3f out_position);

        /// <summary>
        /// Sets the radiation direction for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose direction is being set</param>
        /// <param name="direction">MLQuaternionf struct to set the direction</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// For sounds that have been set to radiate in a directional way
        /// by MLAudioSetSpatialSoundRadiationProperties, this function
        /// sets the direction of the radiation Multi-channel sounds require
        /// the radiation direction to be set individually for each channel by
        /// calling this function once for each channel For mono sounds
        /// use channel = 0 For stereo sounds use channel = 0 for left and
        /// • channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundDirection(MlApi.MLHandle handle, uint channel, in MlTypes.MLQuaternionf direction);

        /// <summary>
        /// Returns the radiation direction for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose direction is being read</param>
        /// <param name="out_direction">MLQuaternionf struct to return the direction</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Multi-channel sounds require the radiation direction to be read
        /// individually for each channel by calling this function once for each
        /// channel For mono sounds use channel = 0 For stereo sounds
        /// use channel = 0 for left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundDirection(MlApi.MLHandle handle, uint channel, ref MlTypes.MLQuaternionf out_direction);

        /// <summary>
        /// Sets the distance properties for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose distance properties are being set</param>
        /// <param name="properties">MLAudioSpatialSoundDistanceProperties struct to set the properties</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// When 3D audio processing is enabled for a sound output (see
        /// MLAudioSetSpatialSoundEnable) this function sets the way in
        /// which distance affects sound volume Multi-channel sounds
        /// require the distance properties to be set individually for each
        /// channel by calling this function once for each channel For mono
        /// sounds use channel = 0 For stereo sounds use channel = 0 for
        /// left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundDistanceProperties(MlApi.MLHandle handle, uint channel, in MlAudio.MLAudioSpatialSoundDistanceProperties properties);

        /// <summary>
        /// Returns the distance properties for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose distance properties are being read</param>
        /// <param name="out_properties">MLAudioSpatialSoundDistanceProperties struct to return the properties</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Multi-channel sounds require the distance properties to be read
        /// individually for each channel by calling this function once for each
        /// channel For mono sounds use channel = 0 For stereo sounds use
        /// channel = 0 for left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundDistanceProperties(MlApi.MLHandle handle, uint channel, ref MlAudio.MLAudioSpatialSoundDistanceProperties out_properties);

        /// <summary>
        /// Sets the radiation properties for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose radiation properties are being set</param>
        /// <param name="properties">MLAudioSpatialSoundRadiationProperties struct to set the properties</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// When 3D audio processing is enabled for a sound output (see
        /// MLAudioSetSpatialSoundEnable) this function sets the degree
        /// of directionality in the sound projection The default setting is for
        /// sounds to be omnidirectional (equal projection in all directions)
        /// Multi-channel sounds require the radiation properties to be set
        /// individually for each channel by calling this function once for each
        /// channel For mono sounds use channel = 0 For stereo sounds use
        /// channel = 0 for left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundRadiationProperties(MlApi.MLHandle handle, uint channel, in MlAudio.MLAudioSpatialSoundRadiationProperties properties);

        /// <summary>
        /// Returns the radiation properties for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose radiation properties are being set</param>
        /// <param name="out_properties">MLAudioSpatialSoundRadiationProperties struct to return the properties</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Multi-channel sounds require the radiation properties to be read
        /// individually for each channel by calling this function once for each
        /// channel For mono sounds use channel = 0 For stereo sounds use
        /// channel = 0 for left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundRadiationProperties(MlApi.MLHandle handle, uint channel, ref MlAudio.MLAudioSpatialSoundRadiationProperties out_properties);

        /// <summary>
        /// Sets the direct send levels for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose direct send levels are being set</param>
        /// <param name="levels">MLAudioSpatialSoundSendLevels struct to set the levels</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// When 3D audio processing is enabled for a sound output (see
        /// MLAudioSetSpatialSoundEnable) this function sets the send
        /// levels for the direct component of the sound, ie, the audio mix
        /// for the the part of the sound not affected by room acoustics
        /// Multi-channel sounds require the direct send levels to be set
        /// individually for each channel by calling this function once for each
        /// channel For mono sounds use channel = 0 For stereo sounds use
        /// channel = 0 for left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundDirectSendLevels(MlApi.MLHandle handle, uint channel, in MlAudio.MLAudioSpatialSoundSendLevels levels);

        /// <summary>
        /// Returns the direct send levels for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose direct send levels are being read</param>
        /// <param name="out_levels">MLAudioSpatialSoundSendLevels struct to return the levels</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Multi-channel sounds require the direct send levels to be read
        /// individually for each channel by calling this function once for each
        /// channel For mono sounds use channel = 0 For stereo sounds use
        /// channel = 0 for left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundDirectSendLevels(MlApi.MLHandle handle, uint channel, ref MlAudio.MLAudioSpatialSoundSendLevels out_levels);

        /// <summary>
        /// Sets the room send levels for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose room send levels are being set</param>
        /// <param name="levels">MLAudioSpatialSoundSendLevels struct to set the levels</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// When 3D audio processing is enabled for a sound output (see
        /// MLAudioSetSpatialSoundEnable) this function sets the send
        /// levels for the room component of the sound, ie, the audio mix
        /// for the the part of the sound that's affected by room acoustics
        /// Multi-channel sounds require the room send levels to be set
        /// individually for each channel by calling this function once for each
        /// channel For mono sounds use channel = 0 For stereo sounds use
        /// channel = 0 for left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundRoomSendLevels(MlApi.MLHandle handle, uint channel, in MlAudio.MLAudioSpatialSoundSendLevels levels);

        /// <summary>
        /// Returns the room send levels for one channel of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="channel">Selects the channel whose room send levels are being read</param>
        /// <param name="out_levels">MLAudioSpatialSoundSendLevels struct to return the levels</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Multi-channel sounds require the room send levels to be read
        /// individually for each channel by calling this function once for each
        /// channel For mono sounds use channel = 0 For stereo sounds use
        /// channel = 0 for left and channel = 1 for right
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundRoomSendLevels(MlApi.MLHandle handle, uint channel, ref MlAudio.MLAudioSpatialSoundSendLevels out_levels);

        /// <summary>
        /// Sets the room acoustics shared by all spatial sounds
        /// </summary>
        /// <param name="properties">MLAudioSpatialSoundRoomProperties struct to set the properties</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// For sound outputs that use 3D audio processing this function sets
        /// the acoustic properties of the "room" that all spatial sounds share
        /// For the time being (until a future update), this global acoustic
        /// setting applies to all LuminRT and native applications and services
        /// You should only use this call if you are an immersive app that needs
        /// specific acoustical properties In that case, you should be sure to
        /// "get" the current settings first, and restore them when you exit
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundRoomProperties(in MlAudio.MLAudioSpatialSoundRoomProperties properties);

        /// <summary>
        /// Returns the room acoustics shared by all spatial sounds
        /// </summary>
        /// <param name="out_properties">MLAudioSpatialSoundRoomProperties struct to return the properties</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// For sound outputs that use 3D audio processing this function reads
        /// the acoustic properties of the "room" that all spatial sounds share
        /// For the time being (until a future update), this global acoustic
        /// setting applies to all LuminRT and native applications and services
        /// You should only use this call if you are an immersive app that needs
        /// specific acoustical properties In that case, you should be sure to
        /// "get" the current settings first, and restore them when you exit
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundRoomProperties(ref MlAudio.MLAudioSpatialSoundRoomProperties out_properties);

        /// <summary>
        /// Sets the control frequencies used for frequency-based settings
        /// </summary>
        /// <param name="frequencies">MLAudioSpatialSoundControlFrequencies struct to set the frequencies</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// For sound outputs that use 3D audio processing this function sets
        /// the control frequencies (lf, mf, hf) that all spatial sounds share
        /// For the time being (until a future update), this global acoustic
        /// setting applies to all LuminRT and native applications and services
        /// You should only use this call if you are an immersive app that needs
        /// specific acoustical properties In that case, you should be sure to
        /// "get" the current settings first, and restore them when you exit
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSpatialSoundControlFrequencies(in MlAudio.MLAudioSpatialSoundControlFrequencies frequencies);

        /// <summary>
        /// Returns the control frequencies used for frequency-based settings
        /// </summary>
        /// <param name="out_frequencies">MLAudioSpatialSoundControlFrequencies struct to return the frequencies</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImpelmented Not impelmented
        /// </returns>
        /// <remarks>
        /// For sound outputs that use 3D audio processing this function reads
        /// the control frequencies (lf, mf, hf) that all spatial sounds share
        /// For the time being (until a future update), this global acoustic
        /// setting applies to all LuminRT and native applications and services
        /// You should only use this call if you are an immersive app that needs
        /// specific acoustical properties In that case, you should be sure to
        /// "get" the current settings first, and restore them when you exit
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSpatialSoundControlFrequencies(ref MlAudio.MLAudioSpatialSoundControlFrequencies out_frequencies);

        /// <summary>
        /// Sets the volume of a sound output using a linear scale
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="volume">The volume that the sound output will be set to</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The range of the volume is 0 to 8, with 0 for silence,
        /// 1 for unity gain, and 8 for 8x gain
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSoundVolumeLinear(MlApi.MLHandle handle, float volume);

        /// <summary>
        /// Returns the volume of a sound output using a linear scale
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_volume">The volume that the sound output is set to</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The range of the volume is 0 to 8, with 0 for silence,
        /// 1 for unity gain, and 8 for 8x gain
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSoundVolumeLinear(MlApi.MLHandle handle, ref float out_volume);

        /// <summary>
        /// Sets the volume of a sound output using a decibel scale
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="volume">The volume that the sound output will be set to</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The range of the volume is -100 db to +18 dB, with -100 dB for
        /// silence, 0 dB for unity gain, and +18 dB for 8x gain
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSoundVolumeDb(MlApi.MLHandle handle, float volume);

        /// <summary>
        /// Returns the volume of a sound output using a decibel scale
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_volume">The volume that the sound output is set to</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The range of the volume is -100 db to +18 dB, with -100 dB for
        /// silence, 0 dB for unity gain, and +18 dB for 8x gain
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSoundVolumeDb(MlApi.MLHandle handle, ref float out_volume);

        /// <summary>
        /// Sets the pitch of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="pitch">The pitch that the sound output will be set to</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_InvalidBufferSize Invalid buffer size
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The range of the pitch is 05 to 20, with 05 being one octave down
        /// and 20 being one octave up (ie, the pitch is a frequency multiple)
        /// A pitch of 10 is the default and means no change
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSoundPitch(MlApi.MLHandle handle, float pitch);

        /// <summary>
        /// Returns the pitch of a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_pitch">The pitch that the sound output is set to</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The range of the pitch is 05 to 20, with 05 being one octave down
        /// and 20 being one octave up (ie, the pitch is a frequency multiple)
        /// A pitch of 10 is the default and means no change
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetSoundPitch(MlApi.MLHandle handle, ref float out_pitch);

        /// <summary>
        /// Mutes or un-mutes a sound output
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="is_muted">Determines whether the sound output is muted or not</param>
        /// <returns>
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// This mute control is entirely under the control of the owner
        /// of the sound output, and is separate from any muting done by
        /// the audio policy manager
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSoundMute(MlApi.MLHandle handle, [MarshalAs(UnmanagedType.U1)] bool is_muted);

        /// <summary>
        /// Returns whether a sound output is muted or not
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_is_muted">Indicates whether the sound output is muted or not</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// This mute control is entirely under the control of the owner
        /// of the sound output, and will not indicate whether the sound
        /// output has been muted by the audio policy manager To find out
        /// about the latter, use MLAudioSetSoundEventCallback to register
        /// a callback that will provide "policy mute" events
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioIsSoundMuted(MlApi.MLHandle handle, ref bool out_is_muted);

        /// <summary>
        /// Sets whether a sound output is looping or not
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="is_looping">Determines whether the sound output is looping or not</param>
        /// <returns>
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Looping is available for sound outputs that play files (loaded,
        /// streamed, system sounds) The loop goes from the very beginning
        /// to the very end of the file Looping does not apply to sound
        /// outputs that are output streams
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetSoundLooping(MlApi.MLHandle handle, [MarshalAs(UnmanagedType.U1)] bool is_looping);

        /// <summary>
        /// Returns whether a sound output is looping or not
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_is_looping">Indicates whether the sound output is looping or not</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioIsSoundLooping(MlApi.MLHandle handle, ref bool out_is_looping);

        /// <summary>
        /// Sets the playback position for a streamed file
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="offset_in_msec">Sets the new playback position</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// This function will cause a streaming file to jump to a new
        /// location The playback position is specified in milliseconds
        /// This function can be used while a streaming file is playing,
        /// paused or stopped
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetStreamedFileOffset(MlApi.MLHandle handle, uint offset_in_msec);

        /// <summary>
        /// Returns the playback position for a streamed file
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_offset_in_msec">Indicates the current playback position</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnvailable Operation unvailable
        /// </returns>
        /// <remarks>
        /// This function can be used while a streaming file is playing,
        /// paused or stopped
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetStreamedFileOffset(MlApi.MLHandle handle, ref uint out_offset_in_msec);

        /// <summary>
        /// Returns whether sound output is being sent to the speakers or earphones
        /// </summary>
        /// <param name="out_current_device">Indicates whether output goes to wearable or analog jack</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// This is a global configuration that is not specific to individual sound outputs
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetOutputDevice(ref MlAudio.MLAudioOutputDevice out_current_device);

        /// <summary>
        /// Returns the preferred (ie best performing) settings for streaming
        /// </summary>
        /// <param name="channel_count">Number of audio channels (eg 2 for stereo)</param>
        /// <param name="samples_per_second">Sample rate for the audio stream</param>
        /// <param name="max_pitch_change">Top pitch (10 - 20) for the audio stream</param>
        /// <param name="out_format">Recommended settings for MLAudioBufferFormat</param>
        /// <param name="out_recommended_size">Recommended size for the streaming buffers</param>
        /// <param name="out_min_size">Minimum allowable size for the streaming buffers</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetOutputStreamDefaults(uint channel_count, uint samples_per_second, float max_pitch_change, ref MlAudio.MLAudioBufferFormat out_format, ref uint out_recommended_size, ref uint out_min_size);

        /// <summary>
        /// Returns the latency for an output stream
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_latency_in_msec">Indicates the latency in milliseconds</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// This function returns the latency between the time a buffer
        /// is passed to the stream via MLAudioReleaseOutputStreamBuffer
        /// and the time its audio is heard at the speakers or earphones
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetOutputStreamLatency(MlApi.MLHandle handle, ref float out_latency_in_msec);

        /// <summary>
        /// Returns the number of audio frames played by an output stream
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_frames_played">The number of audio frames played</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// This function returns the number of frames that have been sent
        /// down to the audio mixer (-not- the number that have been passed
        /// to the stream buffers) since the last time MLAudioStartSound
        /// was called for this stream Note that the perceived sound
        /// may be slightly behind this value due to the stream latency
        /// (which can be queried by calling MLAudioGetOutputStreamLatency)
        /// Pausing and resuming does not affect the frame count
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetOutputStreamFramesPlayed(MlApi.MLHandle handle, ref ulong out_frames_played);

        /// <summary>
        /// Returns an empty buffer for writing more stream data
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <param name="out_buf">MLAudioBuffer containing the buf to write into</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If buffer available and false if not, or if fail
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_BufferNotReady Buffer not ready
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// This function returns a buffer when one of the two streaming buffers
        /// is empty and needs more data It is possible to call this function in
        /// a polling fashion However for greater efficiency it is recommended
        /// to provide a callback to the 'create' function (in which case this
        /// function may be called from within the callback)
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetOutputStreamBuffer(MlApi.MLHandle handle, ref MlAudio.MLAudioBuffer out_buf);

        /// <summary>
        /// Releases a buffer once it has been filled
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound output</param>
        /// <returns>
        /// MLResult_Ok If call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_BufferNotReady Buffer not ready
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// After receiving an empty buffer from MLAudioGetOutputStreamBuffer
        /// and writing audio data into that buffer, call this function to
        /// indicate that the buffer has been filled and can now be played
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioReleaseOutputStreamBuffer(MlApi.MLHandle handle);

        /// <summary>
        /// Returns the master volume for the audio system
        /// </summary>
        /// <param name="out_volume">The current setting of master volume</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_PriviligeDenied Privilige denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The range of the volume is 0-10, with 0 being silent and 10 being full volume
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetMasterVolume(ref float out_volume);

        /// <summary>
        /// Registers a callback for changes to the master volume
        /// </summary>
        /// <param name="callback">MLAudioMasterVolumeChangedCallback function pointer</param>
        /// <param name="callback_context">Generic data pointer passed back to callback</param>
        /// <returns>
        /// MLResult_AllocFailed Alloc failed
        /// MLResult_Ok If the call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The callback will be called whenever the master volume
        /// gets changed (even if changed by the owner of the callback)
        /// The 'callback_context' argument is passed back to the callback
        /// as its first argument, and the new master volume setting is
        /// passed to the callback as its second argument
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetMasterVolumeCallback(MlAudio.MLAudioMasterVolumeChangedCallback callback, IntPtr callback_context);

        /// <summary>
        /// Creates a new sound input that provides a "voice communications" stream
        /// </summary>
        /// <param name="format">MLAudioBufferFormat specifying the audio format of the stream</param>
        /// <param name="buffer_size">Tequested size in bytes for each of the two stream buffers</param>
        /// <param name="callback">MLAudioBufferCallback function pointer</param>
        /// <param name="callback_context">Generic data pointer passed back to callback</param>
        /// <param name="out_handle">MLHandle used in subsequent calls for this sound input</param>
        /// <returns>
        /// MLResult_AllocFailed Alloc failed
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If input creation was successful
        /// MLResult_PrivilegeDenied If AudioCaptureMic privilege is not allowed
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_InvalidBitsPerSample Invalid bits per sample
        /// MLAudioResult_InvalidBufferSize Invalid buffer size
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleFormat Invalid sample format
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_InvalidValidBits Invalid valid bits
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Creates a sound input and allocates a double-buffer for streaming audio
        /// data from it The "voice communications" stream provides the user's voice
        /// processed for communications, with other sounds rejected It is an
        /// inherently mono stream, so if stereo is requested the mono data will
        /// be duplicated in both channels To stream  data from the buffers call
        /// MLAudioGetInputStreamBuffer to get a full buffer, then read the data
        /// from the buffer, then call MLAudioReleaseInputStreamBuffer to indicate
        /// that the buffer is ready to re-use This can be done either on a polling
        /// basis or within a callback set via the 'callback' argument  The 'format'
        /// argument specifies the format of which the following are supported:
        /// a single mono channel, 16 bit integer, a sampling rate of 16k The
        /// 'buffer_size' argument will use the recommended size if 0 is passed in
        /// After creation, the input can be started by calling MLAudioStartInput
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateInputFromVoiceComm(in MlAudio.MLAudioBufferFormat format, uint buffer_size, MlAudio.MLAudioBufferCallback callback, IntPtr callback_context, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Creates a new sound input that provides a "world capture" stream
        /// </summary>
        /// <param name="format">MLAudioBufferFormat specifying the audio format of the stream</param>
        /// <param name="buffer_size">Requested size in bytes for each of the two stream buffers</param>
        /// <param name="callback">MLAudioBufferCallback function pointer</param>
        /// <param name="callback_context">Generic data pointer passed back to callback</param>
        /// <param name="out_handle">MLHandle used in subsequent calls for this sound input</param>
        /// <returns>
        /// MLResult_AllocFailed Alloc failed
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If input creation was successful
        /// MLResult_PrivilegeDenied If AudioCaptureMic privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_InvalidBitsPerSample Invalid bits per sample
        /// MLAudioResult_InvalidBufferSize Invalid buffer size
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleFormat Invalid sample format
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_InvalidValidBits Invalid valid bits
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Creates a sound input and allocates a double-buffer for streaming audio
        /// data from it The "world capture" stream provides a stereo stream
        /// capturing the user's surroundings To stream  data from the buffers call
        /// MLAudioGetInputStreamBuffer to get a full buffer, then read the data
        /// from the buffer, then call MLAudioReleaseInputStreamBuffer to indicate
        /// that the buffer is ready to re-use This can be done either on a polling
        /// basis or within a callback set via the 'callback' argument The 'format'
        /// argument specifies the format of which the following are supported:
        /// two channels (stereo), 16 bit integer, a sampling rate of 48k The
        /// 'buffer_size' argument will use the recommended size if 0 is passed in
        /// After creation, the input can be started by calling MLAudioStartInput
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateInputFromWorldCapture(in MlAudio.MLAudioBufferFormat format, uint buffer_size, MlAudio.MLAudioBufferCallback callback, IntPtr callback_context, ref MlApi.MLHandle out_handle);

        /// <summary>
        /// Destroys a previously created sound input
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound input</param>
        /// <returns>
        /// MLResult_Ok if input destruction was successful
        /// MLResult_PrivilegeDenied Privilege denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioDestroyInput(MlApi.MLHandle handle);

        /// <summary>
        /// Starts capture for a sound input
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound input</param>
        /// <returns>
        /// MLResult_Ok If starting was successful
        /// MLResult_PrivilegeDenied if original privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioStartInput(MlApi.MLHandle handle);

        /// <summary>
        /// Stops capture for a sound input
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound input</param>
        /// <returns>
        /// MLResult_Ok If stopping was successful
        /// MLResult_PrivilegeDenied If original privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioStopInput(MlApi.MLHandle handle);

        /// <summary>
        /// Indicates the play state of a sound input
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound input</param>
        /// <param name="out_state">Indicates the current play state</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_PrivilegeDenied If original privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The MLAudioState indicates whether the sound input is
        /// stopped or playing
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetInputState(MlApi.MLHandle handle, ref MlAudio.MLAudioState out_state);

        /// <summary>
        /// Registers a callback for events on a sound input
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound input</param>
        /// <param name="callback">MLAudioEventCallback function pointer</param>
        /// <param name="callback_context">Generic data pointer passed back to callback</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_PrivilegeDenied If original privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// Currently only one event can result in a callback being called:
        /// a sound input being muted or unmuted by the audio policy manager
        /// The 'callback_context' argument is passed back to the callback
        /// as its first argument The particular event type (MLAudioEvent)
        /// that caused the callback is passed to the callback as its second
        /// argument
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetInputEventCallback(MlApi.MLHandle handle, MlAudio.MLAudioEventCallback callback, IntPtr callback_context);

        /// <summary>
        /// Returns the preferred (ie best performing) settings for streaming
        /// </summary>
        /// <param name="channel_count">Number of audio channels (eg 2 for stereo)</param>
        /// <param name="samples_per_second">Sample rate for the audio stream</param>
        /// <param name="out_format">Recommended settings for MLAudioBufferFormat</param>
        /// <param name="out_recommended_size">Recommended size for the streaming buffers</param>
        /// <param name="out_min_size">Minimum allowable size for the streaming buffers</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If call was successful
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InvalidChannelCount Invalid channel count
        /// MLAudioResult_InvalidSampleRate Invalid sample rate
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetInputStreamDefaults(uint channel_count, uint samples_per_second, ref MlAudio.MLAudioBufferFormat out_format, ref uint out_recommended_size, ref uint out_min_size);

        /// <summary>
        /// Returns the latency for a sound input
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound input</param>
        /// <param name="out_latency_in_msec">Indicates the latency in milliseconds</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If call was successful
        /// MLResult_PrivilegeDenied If original privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// This function returns the latency between the time a sound
        /// occurs in the real world and the time it becomes available
        /// via MLAudioGetInputStreamBuffer
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetInputStreamLatency(MlApi.MLHandle handle, ref float out_latency_in_msec);

        /// <summary>
        /// Returns a full buffer containing captured audio data
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound input</param>
        /// <param name="out_buf">MLAudioBuffer containing the buf to read from</param>
        /// <returns>
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If buffer available and false if not, or if fail
        /// MLResult_PrivilegeDenied If original privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_BufferNotReady Buffer not ready
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// This function returns a buffer when one of the two streaming buffers
        /// is full and needs to be read It is possible to call this function in
        /// a polling fashion However for greater efficiency it is recommended
        /// to provide a callback to the 'create' function (in which case this
        /// function may be called from within the callback)
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioGetInputStreamBuffer(MlApi.MLHandle handle, ref MlAudio.MLAudioBuffer out_buf);

        /// <summary>
        /// Releases a buffer once it has been read
        /// </summary>
        /// <param name="handle">MLHandle used to identify the sound input</param>
        /// <returns>
        /// MLResult_Ok If call was successful
        /// MLResult_PrivilegeDenied If original privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_BufferNotReady Buffer not ready
        /// MLAudioResult_HandleNotFound Handle not found
        /// MLAudioResult_InternalConfigError Internal config error
        /// MLAudioResult_NotImplemented Internal error
        /// MLAudioResult_OperationUnavailable Operation unavailable
        /// </returns>
        /// <remarks>
        /// After receiving a full buffer from MLAudioGetInputStreamBuffer and
        /// reading the audio data from that buffer, call this function to
        /// indicate that the buffer has been read and can now be re-used
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioReleaseInputStreamBuffer(MlApi.MLHandle handle);

        /// <summary>
        /// Mutes or un-mutes all microphone capture
        /// </summary>
        /// <param name="is_muted">Determines whether mic capture is muted or not</param>
        /// <returns>
        /// MLResult_Ok If the call was successful
        /// MLResult_PrivilegeDenied If AudioCaptureMic privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// This mute control applies to all microphone capture
        /// in general (excluding "recognizer voice" which is
        /// always active) When mic capture is muted or unmuted by
        /// one app, it is muted or unmuted for all apps Note:
        /// this setting is separate from any muting done by
        /// the audio policy manager (such as when the "reality
        /// button" is pressed)
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetMicMute([MarshalAs(UnmanagedType.U1)] bool is_muted);

        /// <summary>
        /// Returns whether all microphone capture is muted or not
        /// </summary>
        /// <param name="out_is_muted">Indicates whether the mic capture is muted or not</param>
        /// <returns>
        /// MLResult_AllocFailed Alloc failed
        /// MLResult_InvalidParam If input parameter is invalid
        /// MLResult_Ok If the call was successful
        /// MLResult_PrivilegeDenied If AudioCaptureMic privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// This function will not indicate whether the microphone capture
        /// has been muted by the audio policy manager To find out
        /// about the latter, use MLAudioSetInputEventCallback to register
        /// a callback that will provide "policy mute" events
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioIsMicMuted(ref bool out_is_muted);

        /// <summary>
        /// Registers a callback for changes to the global mic mute
        /// </summary>
        /// <param name="callback">MLAudioMicMuteCallback function pointer</param>
        /// <param name="callback_context">Generic data pointer passed back to callback</param>
        /// <returns>
        /// MLResult_AllocFailed Alloc failed
        /// MLResult_Ok If the call was successful
        /// MLResult_PrivilegeDenied If AudioCaptureMic privilege is denied
        /// MLResult_UnspecifiedFailure Internal error
        /// MLAudioResult_NotImplemented Internal error
        /// </returns>
        /// <remarks>
        /// The callback will be called whenever the global mic mute
        /// gets changed (even if changed by the owner of the callback)
        /// The 'callback_context' argument is passed back to the callback
        /// as its first argument, and the new mic mute setting is passed
        /// to the callback as its second argument
        /// @priv AudioCaptureMic
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioSetMicMuteCallback(MlAudio.MLAudioMicMuteCallback callback, IntPtr callback_context);

        /// <summary>
/// 
        /// </summary>
        /// <remarks>
        /// This function has been deprecated, and scheduled for removal
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateInputFromVirtualCapture(in MlAudio.MLAudioBufferFormat format, uint buffer_size, MlAudio.MLAudioBufferCallback callback, IntPtr callback_context, ref MlApi.MLHandle out_handle);

        /// <summary>
/// 
        /// </summary>
        /// <remarks>
        /// This function has been deprecated, and scheduled for removal
        /// </remarks>
        [DllImport("ml_audio", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLAudioCreateInputFromMixedCapture(in MlAudio.MLAudioBufferFormat format, uint buffer_size, MlAudio.MLAudioBufferCallback callback, IntPtr callback_context, ref MlApi.MLHandle out_handle);
    }
}

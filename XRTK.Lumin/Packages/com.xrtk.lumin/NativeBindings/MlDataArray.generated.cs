//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

namespace XRTK.Lumin.Native.Bindings
{
    using System.Runtime.InteropServices;

    internal static class MlDataArray
    {
        /// <summary>
        /// Information about the data contained inside of a data array
        /// </summary>
        public enum MLDataArrayType : int
        {
            /// <summary>
            /// No data is contained
            /// </summary>
            MLDataArrayType_None,

            /// <summary>
            /// Data is XYZ floats Use the xyz member of the data array
            /// </summary>
            MLDataArrayType_XYZ,

            /// <summary>
            /// Data is an array of handles to other data arrays Use the handle member of the data array
            /// </summary>
            MLDataArrayType_Handle,

            /// <summary>
            /// Data is an array of uint32_t data
            /// </summary>
            MLDataArrayType_UInt,

            /// <summary>
            /// Data is an array of float data
            /// </summary>
            MLDataArrayType_Float,

            /// <summary>
            /// Data is in a custom format Use custom to get a void* pointer
            /// </summary>
            MLDataArrayType_Custom,

            /// <summary>
            /// Ensure enum is represented as 32 bits
            /// </summary>
            MLDataArrayType_Ensure32Bits = unchecked((int)0x7FFFFFFF),
        }

        public const int MLDataArrayDiff_BlobSize = unchecked((int)32);

        public const int MLDataArray_MaxStreamCount = unchecked((int)8);

        public const int MLDataArray_InvalidStreamIndex = unchecked((int)0xFFFFFFFFu);

        /// <summary>
        /// In/Out parameter to understand whether the data array has changed since the last time it was queried
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLDataArrayDiff
        {
            /// <summary>
            /// A blob of data which is used internally to keep track of
            /// whether changes occurred This data must be initialized with MLDataArrayInitDiff
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 32)]
            public byte[] blob;
        }

        /// <summary>
        /// Defines the characteristics (type, size, count) of the block of data
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLDataArrayStream
        {
            [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Ansi)]
            public struct MLDataArrayStreamunion
            {
                /// <summary>
                /// Data if type is MLDataArrayType_XYZ
                /// </summary>
                [FieldOffset(0)]
                public IntPtr xyz_array;

                /// <summary>
                /// Data if type is MLDataArrayType_Handle
                /// </summary>
                [FieldOffset(0)]
                public IntPtr handle_array;

                /// <summary>
                /// Data if type is MLDataArrayType_UInt
                /// </summary>
                [FieldOffset(0)]
                public IntPtr uint_array;

                /// <summary>
                /// Data if type is MLDataArrayType_Float
                /// </summary>
                [FieldOffset(0)]
                public IntPtr float_array;

                /// <summary>
                /// Data if type is MLDataArrayType_Custom
                /// </summary>
                [FieldOffset(0)]
                public IntPtr custom_array;

                /// <summary>
                /// This ensures that the size of the union remains 8 bytes even on 32-bit platforms
                /// </summary>
                [FieldOffset(0)]
                public ulong ensure_64_bits;
            }

            /// <summary>
            /// The type of data held inside of this array
            /// </summary>
            public MlDataArray.MLDataArrayType type;

            /// <summary>
            /// Number of items contained in the data array
            /// </summary>
            public uint count;

            /// <summary>
            /// Size of each item in this array
            /// </summary>
            public uint data_size;

            /// <summary>
            /// Reserved field
            /// </summary>
            public uint reserved;
        }

        /// <summary>
        /// Handle to a homogenous array of data retrievable via MLDataArrayTryLock
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public readonly struct MLDataArrayHandle : IEquatable<MLDataArrayHandle>
        {
            public MLDataArrayHandle(ulong value) => this.Value = value;

            public readonly ulong Value;

            public bool Equals(MLDataArrayHandle other) => Value.Equals(other.Value);

            public override bool Equals(object obj) => obj is MLDataArrayHandle other && Equals(other);

            public override int GetHashCode() => Value.GetHashCode();

            public override string ToString() => Value.ToString();

            public static implicit operator ulong(MLDataArrayHandle from) => from.Value;

            public static implicit operator MLDataArrayHandle(ulong from) => new MLDataArrayHandle(from);

            public static bool operator ==(MLDataArrayHandle left, MLDataArrayHandle right) => left.Equals(right);

            public static bool operator !=(MLDataArrayHandle left, MLDataArrayHandle right) => !left.Equals(right);
        }

        /// <summary>
        /// Homogeneous data which can be retrieved via MLDataArrayTryLock
        /// </summary>
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)]
        public struct MLDataArray
        {
            /// <summary>
            /// When (in nanoseconds) this object has been last updated
            /// </summary>
            public ulong timestamp;

            /// <summary>
            /// Number of items in the streams list
            /// </summary>
            public uint stream_count;

            /// <summary>
            /// Reserved field
            /// </summary>
            public uint reserved;

            /// <summary>
            /// Array of stream_count data streams containing the data held in this array
            /// </summary>
            [MarshalAs(UnmanagedType.LPArray, SizeConst = 8)]
            public MlDataArray.MLDataArrayStream[] streams;
        }

        /// <summary>
        /// Initialize the MLDataArrayDiff struct
        /// </summary>
        /// <param name="out_diff">the MLDataArrayDiff struct to be initialized</param>
        /// <returns>
        /// MLResult_InvalidParam The out_diff parameter was not valid (null)
        /// MLResult_Ok The operation successed and out_diff contains an initialized diff
        /// MLResult_UnspecifiedFailure Failed to initialize the diff
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDataArrayInitDiff(ref MlDataArray.MLDataArrayDiff out_diff);

        /// <summary>
        /// Request that a data array is locked for reading
        /// </summary>
        /// <param name="data_array">The handle to the data to query</param>
        /// <param name="out_data">Out parameter which contains the data retrieved if successful</param>
        /// <param name="inout_diff">Optional in/out parameter to prevent data from being retrieved
        /// if it hasn't changed since a previous change</param>
        /// <returns>
        /// MLResult_Locked If the array is already locked (and thus could not obtain the lock)
        /// MLResult_Ok If new data is available, and the array has successfully been locked
        /// MLResult_Pending The array contains no new data (array will not be locked after returning this result)
        /// MLResult_UnspecifiedFailure The operation failed for an unspecified reason
        /// </returns>
        /// <remarks>
        /// @priv None
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDataArrayTryLock(MlDataArray.MLDataArrayHandle data_array, ref MlDataArray.MLDataArray out_data, ref MlDataArray.MLDataArrayDiff inout_diff);

        /// <summary>
        /// Unlock a data array previously locked via MLDataArrayTryLock
        /// </summary>
        /// <param name="data_array">The handle which was used to lock this data</param>
        /// <returns>
        /// MLResult_Ok The data array was successfully unlocked
        /// MLResult_UnspecifiedFailure The data array failed to be unlocked
        /// </returns>
        /// <remarks>
        /// This function must be called if MLDataArrayTryLock returned MLDataArrayLockResult_New
        /// Data should be locked for as short of a time as possible because it will block
        /// new data from being updated/processed
        /// @priv None
        /// </remarks>
        [DllImport("ml_perception_client", CallingConvention = CallingConvention.Cdecl)]
        public static extern MlApi.MLResult MLDataArrayUnlock(MlDataArray.MLDataArrayHandle data_array);
    }
}
